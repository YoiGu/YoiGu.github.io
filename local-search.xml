<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LearnOpenGL学习笔记（一）</title>
    <link href="/2024/07/10/LearnOpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2024/07/10/LearnOpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>为终身之路踏上第一步。<br>    <span id="more"></span></p><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>OpenGL可以被看作是一个大的状态机。API中的一些函数会根据当前OpenGL的状态的不同，而产生不同的效果，这些函数被称为状态函数。</p><blockquote><p>OpenGL的工作流：</p><p>创建对象-&gt;绑定对象到上下文（Bind Gen出来的Object到OpenGL上下文的内置属性）-&gt;设置已绑定对象的选项-&gt;解绑对象</p><p>PS：解绑对象只是让对象和上下文之间断开联系。实际上选项已经改变，与解绑无关。当要获取之前那个对象的信息时，只需要重新绑定那个上下文变量就行了。比如说我们有一些作为3D模型数据（一栋房子或一个人物）的容器对象，在我们想绘制其中任何一个模型的时候，只需绑定一个包含对应模型数据的对象就可以了。拥有数个这样的对象允许我们指定多个模型，在想画其中任何一个的时候，直接将对应的对象绑定上去，便不需要再重复设置选项了。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">// 创建对象</span><br>unsigned <span class="hljs-type">int</span> objectId = <span class="hljs-number">0</span>;<br>glGenObject(<span class="hljs-number">1</span>, &amp;objectId);<br><span class="hljs-comment">// 绑定对象至上下文</span><br>glBindObject(GL_WINDOW_TARGET, objectId);<br><span class="hljs-comment">// 设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项</span><br>glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, <span class="hljs-number">800</span>);<br>glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, <span class="hljs-number">600</span>);<br><span class="hljs-comment">// 将上下文对象设回默认</span><br>glBindObject(GL_WINDOW_TARGET, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></blockquote><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="GLFW"><a href="#GLFW" class="headerlink" title="GLFW"></a>GLFW</h3><p>下载源代码，使用Clion打开源代码根目录作为项目。</p><p>点击构建-构建项目，完成后在cmake-build-output&#x2F;src文件夹下找到glfw3.dll文件。</p><p>新建空项目，新建libs和include文件夹，将GLFW源代码中include文件夹的内容拖入新include文件夹，将编译完成的glfw3.dll拖入libs文件夹。<strong>同时，也要把glfw3.dll拖入cmake-build-output文件夹下</strong></p><p>修改CMakeList.txt内容如下:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.28</span>)<br><span class="hljs-keyword">project</span>(LearnOpenGL) <span class="hljs-comment"># 定义项目名</span><br><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><br><span class="hljs-keyword">add_executable</span>(LearnOpenGL main.cpp) <span class="hljs-comment"># 这步必须放在链接操作之前</span><br><br><span class="hljs-keyword">INCLUDE_DIRECTORIES</span>(<span class="hljs-keyword">include</span>) <span class="hljs-comment"># include文件所在路径</span><br><span class="hljs-keyword">link_directories</span>(libs) <span class="hljs-comment"># libs文件所在路径</span><br><span class="hljs-keyword">target_link_libraries</span>(LearnOpenGL libs/glfw3.dll) <span class="hljs-comment"># dll文件所在路径</span><br></code></pre></td></tr></table></figure><p>重新加载CMake即可。可新建cpp文件，输入<code>#include &lt;GLFW\glfw3.h&gt;</code>，若未报错则链接成功。</p><h3 id="GLAD"><a href="#GLAD" class="headerlink" title="GLAD"></a>GLAD</h3><p>打开<a href="http://glad.dav1d.de/%EF%BC%8C%E6%8C%89%E7%85%A7%E4%BB%A5%E4%B8%8B%E8%A7%84%E5%88%99%E9%85%8D%E7%BD%AE%EF%BC%9A">http://glad.dav1d.de/，按照以下规则配置：</a></p><p>Language：C&#x2F;C++</p><p>Specification：OpenGL</p><p>API-gl：3.3 and newer</p><p>Opentions - Generate a loader：打勾</p><p>点击Generate按钮，下载glad.zip，解压，将include内的文件拖动到工程的include文件里，glad.c则放到工程根目录。使用<code>#include &lt;glad\glad.h&gt;</code>验证是否配置成功。</p><h2 id="范例工程"><a href="#范例工程" class="headerlink" title="范例工程"></a>范例工程</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glad/glad.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;GLFW/glfw3.h&gt;</span></span><br></code></pre></td></tr></table></figure><p>注意：<strong>glad头文件必须在GLFW之前include</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glad/glad.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;GLFW/glfw3.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//处理键盘输入，当用户按下ESC键时，提醒程序要退出</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processInput</span><span class="hljs-params">(GLFWwindow *window)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//glfwGetKey函数用于检查一个键是否正在被按下</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)<br>        <span class="hljs-built_in">glfwSetWindowShouldClose</span>(window, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-comment">//回调函数，使视口范围随窗口大小变化。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">framebuffer_size_callback</span><span class="hljs-params">(GLFWwindow* window, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">glViewport</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// -----------glfw初始化与窗口创建-----------</span><br>    <span class="hljs-comment">// 初始化glfw组件</span><br>    <span class="hljs-built_in">glfwInit</span>();<br>    <span class="hljs-comment">//指定opengl版本为3.3</span><br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="hljs-number">3</span>);<br>    <span class="hljs-comment">//告诉glfw我们使用的是核心模式</span><br>    <span class="hljs-comment">//核心模式意味着我们只能使用OpenGL功能的核心功能子集</span><br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE,GLFW_OPENGL_CORE_PROFILE);<br>    <span class="hljs-comment">//创建glfw窗口</span><br>    <span class="hljs-comment">//第一个参数是窗口的宽度，第二个是高度，第三个是窗口的标题，第四个参数指定窗口是否共享资源，第五个参数是共享资源的窗口</span><br>    <span class="hljs-comment">//共享资源指的是多个窗口可以共享同一个上下文</span><br>    GLFWwindow* window = <span class="hljs-built_in">glfwCreateWindow</span>(<span class="hljs-number">800</span>, <span class="hljs-number">600</span>, <span class="hljs-string">&quot;LearnOpenGL&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">//检查窗口是否创建成功</span><br>    <span class="hljs-keyword">if</span> (window == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-comment">//销毁glfw</span><br>        <span class="hljs-built_in">glfwTerminate</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">//通知glfw将我们窗口的上下文设置为当前线程的主上下文</span><br>    <span class="hljs-built_in">glfwMakeContextCurrent</span>(window);<br>    <span class="hljs-comment">// -----------GLAD加载所有OpenGL函数指针-----------</span><br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">//先前只是生成了窗口的大小，但窗口大小与实际渲染区域无关。因此，我们需要定义渲染区域的大小，即视口(Viewport)。</span><br>    <span class="hljs-comment">//视口定义了窗口中可以渲染的区域，将其设置为窗口的维度</span><br>    <span class="hljs-comment">//前两个参数代表渲染区域左下角在GLFW窗口的坐标。第三个和第四个参数是渲染区域的宽度和高度（像素）</span><br>    <span class="hljs-comment">//注意，这里并没有传入window，所以glViewport是个状态使用函数。</span><br>    <span class="hljs-built_in">glViewport</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">800</span>, <span class="hljs-number">600</span>);<br>    <span class="hljs-comment">//为了让窗口被改变时，视口也能相应改变，我们需要注册一个窗口大小的回调函数</span><br>    <span class="hljs-comment">//glfwSetFramebufferSizeCallback函数接受一个窗口，一个函数指针，当窗口大小改变时调用这个函数</span><br>    <span class="hljs-built_in">glfwSetFramebufferSizeCallback</span>(window,framebuffer_size_callback);<br>    <span class="hljs-comment">// -----------渲染循环-----------</span><br>    <span class="hljs-comment">//当窗口被要求关闭时，glfwWindowShouldClose函数返回true</span><br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">glfwWindowShouldClose</span>(window))&#123;<br>        <span class="hljs-comment">// 清除颜色缓冲</span><br>        <span class="hljs-comment">// glClearColor用来设置清空屏幕所用的颜色</span><br>        <span class="hljs-built_in">glClearColor</span>(<span class="hljs-number">0.2f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">1.0f</span>);<br>        <span class="hljs-comment">// 清除颜色缓冲。除此之外还有GL_DEPTH_BUFFER_BIT，GL_STENCIL_BUFFER_BIT，分别用于清除深度缓冲、模板缓冲</span><br>        <span class="hljs-comment">// glClearColor是状态设置函数，而glClear是状态使用函数</span><br>        <span class="hljs-built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<br>        <span class="hljs-comment">// 调用输入函数，处理键盘输入</span><br>        <span class="hljs-built_in">processInput</span>(window);<br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// 这里放渲染指令...</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// 交换缓冲区(双缓冲区的实现, 用于避免图像闪烁)</span><br>        <span class="hljs-built_in">glfwSwapBuffers</span>(window);<br>        <span class="hljs-comment">// 处理事件，比如键盘和鼠标事件，随后更新窗口状态并调用回调函数</span><br>        <span class="hljs-built_in">glfwPollEvents</span>();<br>    &#125;<br>    <span class="hljs-comment">// -----------清理资源-----------</span><br>    <span class="hljs-built_in">glfwDestroyWindow</span>(window);<br>    <span class="hljs-built_in">glfwTerminate</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>通常的OpenGL范例程序：</p><p>初始化GLFW-&gt;设置GLFW信息，如OpenGL版本号-&gt;生成窗口-&gt;设置线程上下文-&gt;使用GLAD获取GL函数-&gt;定义渲染视口大小-&gt;注册各类回调函数-&gt;进入渲染循环-&gt;销毁资源</p><p>渲染循环内部：</p><p>清空缓存-&gt;处理输入-&gt;进行渲染操作（在后缓冲上绘制）-&gt;检查并调用事件，交换缓冲（使后缓冲的内容显示到画面上）</p></blockquote><blockquote><p>GLFW函数可分为两类：状态设置函数和状态使用函数。前者用于设置状态量，后者用于借助已经设置完毕的状态来改变程序行为。</p></blockquote><h2 id="对象绘制"><a href="#对象绘制" class="headerlink" title="对象绘制"></a>对象绘制</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><blockquote><p>顶点数组对象：Vertex Array Object，VAO</p><p>顶点缓冲对象：Vertex Buffer Object，VBO</p><p>元素缓冲对象：Element Buffer Object，EBO 或 索引缓冲对象 Index Buffer Object，IBO</p></blockquote><p>图形渲染管线可以被分为两个部分：</p><ul><li>第一部分负责将3D坐标转换为2D坐标</li><li>第二部分负责将2D坐标转换为有颜色的，实际屏幕上的像素。</li></ul><blockquote><p>2D坐标与像素不同。像素是2D坐标的近似值，受分辨率影响。</p></blockquote><p>着色器是运行在GPU上的处理程序。每个小核心负责一个着色器的计算。</p><p>Vertex Shader、Geometry Shader和Fragment Shader可以由开发者自定义。</p><p><img src="https://learnopengl-cn.github.io/img/01/04/pipeline.png" alt="img"></p><p>Vertex Shader把单独的顶点作为输入，将局部坐标系下的顶点坐标转换到标准化设备坐标（NDC），同时对顶点属性（Vertex Attribute）进行基本处理。</p><blockquote><p>经Vertex Shader处理过的坐标必定是NDC，范围为[-1, 1]</p></blockquote><p>Geometry Shader把一个图元（包括点、线、三角形三种类型）的顶点作为输入，根据需要处理这些顶点，也可以生成新的顶点，用于构建新的形状。</p><blockquote><p>这个过程可选。</p></blockquote><p>Shape Assembly将前阶段的所有顶点作为输入，并将其装配为指定图元的形状。</p><p>Rasterization把图元映射为屏幕上的像素，生成Fragment, 并剔除View以外的所有像素。</p><blockquote><p>glViewport函数定义了视口信息。视口变换（Viewport Transform）将NDC变换为屏幕空间坐标。</p><p>屏幕空间坐标被变换为Fragment，输入到Fragment Shader中。</p></blockquote><p>Fragment Shader用于计算一个像素的最终颜色。该阶段包含3D场景的数据，如光照、阴影等。</p><p>Test and Blending阶段，首先检测所有像素的深度值、模板值，用于判断像素是正面还是背面，并据此决定是否丢弃。随后，根据像素的alpha值，进行blend操作。</p><h3 id="顶点输入"><a href="#顶点输入" class="headerlink" title="顶点输入"></a>顶点输入</h3><p>顶点数据首先被送到顶点着色器。这些数据以顶点缓冲对象（Vertex Buffer Objects, VBO）的状态存储在GPU内存（即显存）中。</p><blockquote><p>使用VBO的优点在于，可以一次发送一大批数据到GPU上，而非一个顶点传送一次。</p><p>CPU到GPU的传输速度较慢，所以要尽量减少传输次数，一次发送尽可能多的数据。</p></blockquote><p>通过**glGenBuffers(int count, unsigned int* VBO)**函数生成VBO对象。生成完毕后，变量VBO将存储VBO实例的id。随后，进行绑定操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VBO;<br><span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;VBO); <span class="hljs-comment">//生成一个VBO对象，带有缓冲区id</span><br><span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);  <span class="hljs-comment">//将该对象绑定到GL上下文的GL_ARRAY_BUFFER目标</span><br></code></pre></td></tr></table></figure><blockquote><p>任何对象在生成以后都需要与GL上下文中的特定目标进行绑定，才能生效。</p><p>每个缓冲区目标都只能同时绑定一个对象。</p><p>GL_ARRAY_BUFFER存储的对象通常是：需要在CPU和GPU之间传输的顶点相关数据。</p></blockquote><p>**glBufferData(CONTEXT_TARGET, int data_len, float[] data, DRAW_FORM)**用于向当前绑定的缓冲区存入用户定义数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> verticals[] = &#123;<br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,<br>     <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,<br>     <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span><br>&#125;;<br><span class="hljs-built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(verticals),verticals, GL_STATIC_DRAW);<br></code></pre></td></tr></table></figure><blockquote><p>DRAW_FORM参数用于指定显卡如何管理存入的数据。</p><ul><li>GL_STATIC_DRAW：存入的数据几乎不会发生变化</li><li>GL_DYNAMIC_DRAW：存入的数据时常会有发生变化</li><li>GL_STREAM_DRAW：存入的数据每时每刻都在变化</li></ul></blockquote><p>至此，顶点已完成了输入，此刻的顶点数据以VBO的形式存储在显存中。</p><h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core //定义版本号和PROFILE模式</span><br><span class="hljs-comment">//定义一个名为aPos的输入变量，其位置索引为0，类型为vec3。</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos;<br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-comment">//将输入的顶点位置转换为4维向量（齐次坐标），并赋值给内建变量gl_Position，该变量表示顶点着色器的输出位置。</span><br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>location变量用于绑定顶点属性的特定位置索引。一般而言，顶点属性都是用float类型存储的。而存放顶点数据的vertical数组又是一维而非二维的。因此，可能出现前N个数据里，数据[0,N-M]是位置数据，而[N-M+1,N]是颜色数据。通过设置不同的location变量，可以解明顶点数据的具体含义。</p><p>gl_Position的值将会成为顶点着色器的输出。</p><p>在实际的顶点着色器中，往往还需要经过坐标变换到NDC的过程。</p></blockquote><p>C++源码文件无法直接嵌入GLSL代码。所以需要在运行时动态编译。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//顶点着色器源码</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *vertexShaderSource = <span class="hljs-string">&quot;#version 330 core\n&quot;</span><br>    <span class="hljs-string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span><br>    <span class="hljs-string">&quot;void main()\n&quot;</span><br>    <span class="hljs-string">&quot;&#123;\n&quot;</span><br>    <span class="hljs-string">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span><br>    <span class="hljs-string">&quot;&#125;\0&quot;</span>;<br><span class="hljs-comment">//用于保存着色器对象ID引用的无符号整数</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> vertexShader;<br><span class="hljs-comment">//使用glCreateShader函数创建指定类型的着色器对象</span><br><span class="hljs-comment">//由于同种类型的着色器只能生成一个，所以可以直接赋值而非传入地址</span><br>vertexShader = <span class="hljs-built_in">glCreateShader</span>(GL_VERTEX_SHADER);<br><span class="hljs-comment">//对于glShaderSource，其参数含义分别为：着色器对象、源码字符串数量、源码字符串首地址、包含每个字符串长度的整数数组。该函数是把“源码字符串”绑定到“着色器对象”的操作。</span><br><span class="hljs-built_in">glShaderSource</span>(vertexShader, <span class="hljs-number">1</span>, &amp;vertexShaderSource, <span class="hljs-literal">NULL</span>);<br><span class="hljs-comment">//进行编译</span><br><span class="hljs-built_in">glCompileShader</span>(vertexShader);<br></code></pre></td></tr></table></figure><p>通过<code>glGetShaderiv</code>函数可以检测编译是否成功。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>  success; <span class="hljs-comment">//是否成功编译的flag</span><br><span class="hljs-type">char</span> infoLog[<span class="hljs-number">512</span>]; <span class="hljs-comment">//错误信息字符数组</span><br><span class="hljs-comment">//glGetShaderiv用于获取着色器信息</span><br><span class="hljs-comment">//第二个参数可替换为以下选项：</span><br><span class="hljs-comment">//GL_SHADER_TYPE：获取着色器类型</span><br><span class="hljs-comment">//..待补充</span><br><span class="hljs-built_in">glGetShaderiv</span>(vertexShader, GL_COMPILE_STATUS, &amp;success); <span class="hljs-comment">//获取编译结果</span><br><span class="hljs-keyword">if</span>(!success)<br>&#123; <span class="hljs-comment">//若未编译成功</span><br>    <span class="hljs-built_in">glGetShaderInfoLog</span>(vertexShader, <span class="hljs-number">512</span>, <span class="hljs-literal">NULL</span>, infoLog); <span class="hljs-comment">//获取编译错误信息,512代表infoLog数组大小</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl; <span class="hljs-comment">//打印</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="片元着色器"><a href="#片元着色器" class="headerlink" title="片元着色器"></a>片元着色器</h3><p>片元着色器用于计算像素最后的颜色输出。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragColor; <span class="hljs-comment">// 片元着色器允许用户自定义输出变量</span><br><span class="hljs-type">void</span> main()<br>&#123;<br>    FragColor = <span class="hljs-type">vec4</span>(<span class="hljs-number">1.0</span>f, <span class="hljs-number">0.5</span>f, <span class="hljs-number">0.2</span>f, <span class="hljs-number">1.0</span>f); <span class="hljs-comment">//橘黄色</span><br>&#125; <br></code></pre></td></tr></table></figure><p>随后进行编译。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* fragmentShaderSource = <span class="hljs-string">&quot;#version 330 core\n&quot;</span><br>    <span class="hljs-string">&quot;out vec4 FragColor;\n&quot;</span><br>    <span class="hljs-string">&quot;void main()\n&quot;</span><br>    <span class="hljs-string">&quot;&#123;\n&quot;</span><br>    <span class="hljs-string">&quot;FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;</span><br>    <span class="hljs-string">&quot;&#125;\n&quot;</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fragmentShader;<br>fragmentShader = <span class="hljs-built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);<br><span class="hljs-built_in">glShaderSource</span>(fragmentShader, <span class="hljs-number">1</span>, &amp;fragmentShaderSource, <span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">glCompileShader</span>(fragmentShader);<br></code></pre></td></tr></table></figure><h3 id="着色器程序"><a href="#着色器程序" class="headerlink" title="着色器程序"></a>着色器程序</h3><p>完成着色器编译后，还需要编写着色器程序。整个渲染管线就像一个链表，着色器是其中的一个个节点，而着色器程序负责把这些节点连接（Link）起来，并负责数据的输入输出。</p><p>当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当输出和输入不匹配的时候，你会得到一个连接错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> shaderProgram; <span class="hljs-comment">//句柄</span><br>shaderProgram = <span class="hljs-built_in">glCreateProgram</span>();<br><span class="hljs-comment">//注意Attach操作的顺序</span><br><span class="hljs-built_in">glAttachShader</span>(shaderProgram, vertexShader);<br><span class="hljs-built_in">glAttachShader</span>(shaderProgram, fragmentShader);<br><span class="hljs-comment">//完成Attach以后，进行Link操作。</span><br><span class="hljs-built_in">glLinkProgram</span>(shaderProgram);<br></code></pre></td></tr></table></figure><p>借助<code>glGetProgramiv</code>函数，可以判断链接是否出错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">glGetProgramiv</span>(shaderProgram, GL_LINK_STATUS, &amp;success);<br><span class="hljs-keyword">if</span>(!success) &#123;<br>    <span class="hljs-built_in">glGetProgramInfoLog</span>(shaderProgram, <span class="hljs-number">512</span>, <span class="hljs-literal">NULL</span>, infoLog);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>链接完毕后，使用<code>glUseProgram</code>函数激活着色器程序对象，同时，删除先前定义的着色器，以释放内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">glUseProgram</span>(shaderProgram);<br><span class="hljs-built_in">glDeleteShader</span>(vertexShader);<br><span class="hljs-built_in">glDeleteShader</span>(fragmentShader);<br></code></pre></td></tr></table></figure><p>完成这一系列操作以后，我们完成了以下内容：</p><ul><li>发送顶点数据，让其以VBO的状态存储在显存。</li><li>编写了Vertex Shader和Fragment Shader，并指示GPU该如何使用这些着色器处理顶点数据。</li></ul><h3 id="链接顶点属性"><a href="#链接顶点属性" class="headerlink" title="链接顶点属性"></a>链接顶点属性</h3><p>我们输入的verticals数组是一个一维float数组。在这个数组里，每3个元素代表着一个顶点的位置数据。但OpenGL不知道，所以我们要告诉OpenGL，数组的哪些位置代表着哪个顶点的什么属性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//指定解析顶点数据的方式</span><br><span class="hljs-comment">//第一个参数指定我们要配置的顶点属性，即着色器中的location。位置信息是一个location，颜色信息就是另一个location</span><br><span class="hljs-comment">//第二个参数指定顶点数据的大小，也就是每个属性的维度数。位置数据是一个三维向量，所以输入3</span><br><span class="hljs-comment">//第三个参数指定数据的类型</span><br><span class="hljs-comment">//第四个参数指定是否归一化，映射到0-1(或-1到1，对于有符号数来说。)</span><br><span class="hljs-comment">//第五个参数指定步长，即：这个属性第二次出现的地方到整个数组0位置之间有多少字节。对于单一属性数组，可设置为0</span><br><span class="hljs-comment">//第六个参数表示数据在缓冲区相对于起始位置的偏移量。如：位置信息包含3字节，紧随其后的是颜色信息。那么对于位置信息，这个参数就是(void*)0，对于颜色信息就是(void*)3</span><br><span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<br><span class="hljs-comment">//设置完成后，启用顶点属性</span><br><span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">0</span>);<br><span class="hljs-comment">//随后启用着色器程序</span><br><span class="hljs-built_in">glUseProgram</span>(shaderProgram);<br></code></pre></td></tr></table></figure><h3 id="顶点数组对象"><a href="#顶点数组对象" class="headerlink" title="顶点数组对象"></a>顶点数组对象</h3><p>所以，每次绘制一个物体，我们都必须经历以下步骤：</p><ul><li>生成VBO对象</li><li>绑定VBO对象到GL_ARRAY_BUFFER</li><li>将顶点数据（float数组）传入GL_ARRAY_BUFFER</li><li>设置顶点属性指针</li><li>启用顶点属性</li><li>使用着色器程序</li><li>绘制物体</li></ul><p>非常繁琐。为了减少工作量，我们引入顶点数组对象（Vertex Array Object，VAO）的概念。</p><p>一个顶点数组对象会储存以下这些内容：</p><ul><li>glEnableVertexAttribArray和glDisableVertexAttribArray的调用。</li><li>通过glVertexAttribPointer设置的顶点属性配置。</li><li>通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。</li></ul><p>一般，完整的渲染代码可以表示为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ..:: 初始化代码（只运行一次 (除非你的物体频繁改变)） :: ..</span><br><span class="hljs-comment">// 生成VAO、VBO对象....</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VAO;<br><span class="hljs-built_in">glGenVertexArrays</span>(<span class="hljs-number">1</span>, &amp;VAO);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VBO;<br><span class="hljs-built_in">glGenVertexArrays</span>(<span class="hljs-number">1</span>, &amp;VBO);<br><span class="hljs-comment">// 1. 绑定VAO</span><br><span class="hljs-built_in">glBindVertexArray</span>(VAO);<br><span class="hljs-comment">// 2. 把顶点数组复制到缓冲中供OpenGL使用</span><br><span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);<br><span class="hljs-built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<br><span class="hljs-comment">// 3. 设置顶点属性指针</span><br><span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<br><span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">0</span>);<br><span class="hljs-comment">// ..:: 绘制代码（渲染循环中） :: ..</span><br><span class="hljs-comment">// 4. 绘制物体</span><br><span class="hljs-built_in">glUseProgram</span>(shaderProgram);<br><span class="hljs-built_in">glBindVertexArray</span>(VAO);<br><span class="hljs-built_in">someOpenGLFunctionThatDrawsOurTriangle</span>();<br></code></pre></td></tr></table></figure><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p><code>glDrawArray</code>函数使用当前激活的着色器和VAO（包含VBO信息）来绘制图元（点、线、三角）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">glUseProgram</span>(shaderProgram);<br><span class="hljs-built_in">glBindVertexArray</span>(VAO);<br><span class="hljs-comment">// 第一个参数表示图元类型</span><br><span class="hljs-comment">// 第二个参数表示顶点数组起始索引</span><br><span class="hljs-comment">// 第三个表示绘制的顶点数量</span><br><span class="hljs-built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glad/glad.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;GLFW/glfw3.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//顶点数据</span><br><span class="hljs-type">float</span> verticals[] = &#123;<br>        <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,<br>        <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,<br>        <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span><br>&#125;;<br><br><span class="hljs-comment">//顶点着色器源码</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* vertex_shader=<span class="hljs-string">&quot;#version 330 core\n&quot;</span><br>                          <span class="hljs-string">&quot;layout(location=0) in vec3 aPos;\n&quot;</span><br>                          <span class="hljs-string">&quot;void main()\n&quot;</span><br>                          <span class="hljs-string">&quot;&#123;\n&quot;</span><br>                          <span class="hljs-string">&quot;gl_Position = vec4(aPos,1.0);&quot;</span><br>                          <span class="hljs-string">&quot;&#125;\n&quot;</span>;<br><br><span class="hljs-comment">//片段着色器源码</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* fragment_shader=<span class="hljs-string">&quot;#version 330 core\n&quot;</span><br>                            <span class="hljs-string">&quot;out vec4 Fragcolor;\n&quot;</span><br>                            <span class="hljs-string">&quot;void main()\n&quot;</span><br>                            <span class="hljs-string">&quot;&#123;\n&quot;</span><br>                            <span class="hljs-string">&quot;Fragcolor = vec4(1.0f, 0.5f, 0.2f, 1.0f);&quot;</span><br>                            <span class="hljs-string">&quot;&#125;\n&quot;</span>;<br><br><span class="hljs-comment">//输入处理函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process_input</span><span class="hljs-params">(GLFWwindow* window, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span></span>&#123;<br>    <span class="hljs-built_in">glViewport</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,width,height);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//初始化glfw并配置版本和PROFILE模式</span><br>    <span class="hljs-built_in">glfwInit</span>();<br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR,<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR,<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE,GLFW_OPENGL_CORE_PROFILE);<br>    <span class="hljs-comment">//创建glfw窗口</span><br>    GLFWwindow* window = <span class="hljs-built_in">glfwCreateWindow</span>(<span class="hljs-number">800</span>,<span class="hljs-number">600</span>,<span class="hljs-string">&quot;LearnOpenGL&quot;</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">//创建错误处理</span><br>    <span class="hljs-keyword">if</span>(window==<span class="hljs-literal">NULL</span>)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Failed to create GLFW Window!&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-built_in">glfwTerminate</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">//将窗口上下文设置为当前线程上下文</span><br>    <span class="hljs-built_in">glfwMakeContextCurrent</span>(window);<br>    <span class="hljs-comment">//加载glad函数</span><br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Failed to load proc&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">//定义视口大小</span><br>    <span class="hljs-built_in">glViewport</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">800</span>,<span class="hljs-number">600</span>);<br>    <span class="hljs-comment">//配置窗口大小改变的回调函数，使得窗口改变时视口随之改变</span><br>    <span class="hljs-built_in">glfwSetFramebufferSizeCallback</span>(window,process_input);<br>    <span class="hljs-comment">//创建、绑定VBO对象</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VBO;<br>    <span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>,&amp;VBO);<br>    <span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER,VBO);<br>    <span class="hljs-built_in">glBufferData</span>(GL_ARRAY_BUFFER,<span class="hljs-built_in">sizeof</span>(verticals),verticals,GL_STATIC_DRAW);<br>    <span class="hljs-comment">//创建、绑定VAO对象</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VAO;<br>    <span class="hljs-built_in">glGenVertexArrays</span>(<span class="hljs-number">1</span>,&amp;VAO);<br>    <span class="hljs-built_in">glBindVertexArray</span>(VAO);<br>    <span class="hljs-comment">//配置顶点属性指针，说明顶点数据与属性的对应关系</span><br>    <span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,GL_FLOAT,GL_FALSE,<span class="hljs-number">0</span>,(<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//启用顶点属性</span><br>    <span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//创建顶点着色器</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> vertex = <span class="hljs-built_in">glCreateShader</span>(GL_VERTEX_SHADER);<br>    <span class="hljs-comment">//链接着色器对象与源代码</span><br>    <span class="hljs-built_in">glShaderSource</span>(vertex,<span class="hljs-number">1</span>,&amp;vertex_shader,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">//编译着色器</span><br>    <span class="hljs-built_in">glCompileShader</span>(vertex);<br>    <span class="hljs-type">int</span>  success; <span class="hljs-comment">//是否成功编译的flag</span><br>    <span class="hljs-type">char</span> infoLog[<span class="hljs-number">512</span>]; <span class="hljs-comment">//错误信息字符数组</span><br>    <span class="hljs-built_in">glGetShaderiv</span>(vertex, GL_COMPILE_STATUS, &amp;success); <span class="hljs-comment">//获取编译结果</span><br>    <span class="hljs-keyword">if</span>(!success)<br>    &#123; <span class="hljs-comment">//若未编译成功</span><br>        <span class="hljs-built_in">glGetShaderInfoLog</span>(vertex, <span class="hljs-number">512</span>, <span class="hljs-literal">NULL</span>, infoLog); <span class="hljs-comment">//获取编译错误信息,512代表infoLog数组大小</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl; <span class="hljs-comment">//打印</span><br>    &#125;<br>    <span class="hljs-comment">//同上</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fragment = <span class="hljs-built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);<br>    <span class="hljs-built_in">glShaderSource</span>(fragment,<span class="hljs-number">1</span>,&amp;fragment_shader,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">glCompileShader</span>(fragment);<br>    <span class="hljs-built_in">glGetShaderiv</span>(fragment, GL_COMPILE_STATUS, &amp;success); <span class="hljs-comment">//获取编译结果</span><br>    <span class="hljs-keyword">if</span>(!success)<br>    &#123; <span class="hljs-comment">//若未编译成功</span><br>        <span class="hljs-built_in">glGetShaderInfoLog</span>(fragment, <span class="hljs-number">512</span>, <span class="hljs-literal">NULL</span>, infoLog); <span class="hljs-comment">//获取编译错误信息,512代表infoLog数组大小</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl; <span class="hljs-comment">//打印</span><br>    &#125;<br>    <span class="hljs-comment">//创建着色器程序</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> shader_program = <span class="hljs-built_in">glCreateProgram</span>();<br>    <span class="hljs-comment">//添加着色器“节点”，注意顺序</span><br>    <span class="hljs-built_in">glAttachShader</span>(shader_program,vertex);<br>    <span class="hljs-built_in">glAttachShader</span>(shader_program,fragment);<br>    <span class="hljs-comment">//完成链接操作</span><br>    <span class="hljs-built_in">glLinkProgram</span>(shader_program);<br>    <span class="hljs-comment">//激活着色器程序</span><br>    <span class="hljs-built_in">glUseProgram</span>(shader_program);<br>    <span class="hljs-comment">//删除着色器对象，释放内存</span><br>    <span class="hljs-built_in">glDeleteShader</span>(vertex);<br>    <span class="hljs-built_in">glDeleteShader</span>(fragment);<br>    <span class="hljs-comment">//渲染循环</span><br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">glfwWindowShouldClose</span>(window))&#123;<br>        <span class="hljs-comment">//设置清空颜色</span><br>        <span class="hljs-built_in">glClearColor</span>(<span class="hljs-number">0.2f</span>,<span class="hljs-number">0.3f</span>,<span class="hljs-number">0.3f</span>,<span class="hljs-number">1.0f</span>);<br>        <span class="hljs-comment">//清空上一帧</span><br>        <span class="hljs-built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<br>        <span class="hljs-comment">//激活着色器程序</span><br>        <span class="hljs-built_in">glUseProgram</span>(shader_program);<br>        <span class="hljs-comment">//绑定VAO对象</span><br>        <span class="hljs-built_in">glBindVertexArray</span>(VAO);<br>        <span class="hljs-comment">//绘制三个顶点的三角形图元</span><br>        <span class="hljs-built_in">glDrawArrays</span>(GL_TRIANGLES,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">//交换前后缓冲</span><br>        <span class="hljs-built_in">glfwSwapBuffers</span>(window);<br>        <span class="hljs-comment">//处理外部输入</span><br>        <span class="hljs-built_in">glfwPollEvents</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="元素缓冲对象"><a href="#元素缓冲对象" class="headerlink" title="元素缓冲对象"></a>元素缓冲对象</h3><p>当图元存在共用顶点的情况时，传统的绘制方法会把共用的顶点绘制两次，导致额外开销。</p><p>为此，元素缓冲对象（Element Buffer Object, EBO）提供了一种方式，用于存储OpenGL用来决定要绘制哪些顶点的索引。</p><p>使用EBO时，顶点数据必须是不重复的顶点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> vertices[] = &#123;<br>    <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// 右上角</span><br>    <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// 右下角</span><br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">// 左下角</span><br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>   <span class="hljs-comment">// 左上角</span><br>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> indices[] = &#123;<br>    <span class="hljs-comment">// 注意索引从0开始! </span><br>    <span class="hljs-comment">// 此例的索引(0,1,2,3)就是顶点数组vertices的下标，</span><br>    <span class="hljs-comment">// 这样可以由下标代表顶点组合成矩形</span><br>    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-comment">// 第一个三角形</span><br>    <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>  <span class="hljs-comment">// 第二个三角形</span><br>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> EBO;<br><span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;EBO);<br><span class="hljs-built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);<br><span class="hljs-built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);<br><span class="hljs-comment">//渲染循环内...</span><br><span class="hljs-built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);<br><span class="hljs-built_in">glDrawElements</span>(GL_TRIANGLES, <span class="hljs-number">6</span>, GL_UNSIGNED_INT, <span class="hljs-number">0</span>); <span class="hljs-comment">//注意，使用EBO时需要使用glDrawElements。其中，第四个参数表示EBO中的偏移量。</span><br></code></pre></td></tr></table></figure><p>使用EBO的完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glad/glad.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;GLFW/glfw3.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">float</span> vertices[] = &#123;<br>        <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// 右上角</span><br>        <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// 右下角</span><br>        <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">// 左下角</span><br>        <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>   <span class="hljs-comment">// 左上角</span><br>&#125;;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> indices[] = &#123;<br>        <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-comment">// 第一个三角形</span><br>        <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>  <span class="hljs-comment">// 第二个三角形</span><br>&#125;;<br><br><span class="hljs-comment">//顶点着色器源码</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* vertex_shader=<span class="hljs-string">&quot;#version 330 core\n&quot;</span><br>                          <span class="hljs-string">&quot;layout(location=0) in vec3 aPos;\n&quot;</span><br>                          <span class="hljs-string">&quot;void main()\n&quot;</span><br>                          <span class="hljs-string">&quot;&#123;\n&quot;</span><br>                          <span class="hljs-string">&quot;gl_Position = vec4(aPos,1.0);&quot;</span><br>                          <span class="hljs-string">&quot;&#125;\n&quot;</span>;<br><br><span class="hljs-comment">//片段着色器源码</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* fragment_shader=<span class="hljs-string">&quot;#version 330 core\n&quot;</span><br>                            <span class="hljs-string">&quot;out vec4 Fragcolor;\n&quot;</span><br>                            <span class="hljs-string">&quot;void main()\n&quot;</span><br>                            <span class="hljs-string">&quot;&#123;\n&quot;</span><br>                            <span class="hljs-string">&quot;Fragcolor = vec4(1.0f, 0.5f, 0.2f, 1.0f);&quot;</span><br>                            <span class="hljs-string">&quot;&#125;\n&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process_input</span><span class="hljs-params">(GLFWwindow* window,<span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span></span>&#123;<br>    <span class="hljs-built_in">glViewport</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,width,height);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">glfwInit</span>();<br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR,<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR,<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE,GLFW_OPENGL_CORE_PROFILE);<br>    GLFWwindow* window = <span class="hljs-built_in">glfwCreateWindow</span>(<span class="hljs-number">800</span>,<span class="hljs-number">600</span>,<span class="hljs-string">&quot;LearnOpenGL&quot;</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(window==<span class="hljs-literal">NULL</span>)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Failed to Create Window&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-built_in">glfwTerminate</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">glfwMakeContextCurrent</span>(window);<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">gladLoadGLLoader</span>((GLADloadproc) glfwGetProcAddress))&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Failed to Load GLAD proc&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-built_in">glfwTerminate</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">glViewport</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">800</span>,<span class="hljs-number">600</span>);<br>    <span class="hljs-built_in">glfwSetFramebufferSizeCallback</span>(window,process_input);<br><br>    <span class="hljs-comment">//编译着色器</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> vertex = <span class="hljs-built_in">glCreateShader</span>(GL_VERTEX_SHADER);<br>    <span class="hljs-built_in">glShaderSource</span>(vertex,<span class="hljs-number">1</span>,&amp;vertex_shader,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">glCompileShader</span>(vertex);<br>    <span class="hljs-type">int</span> success;<br>    <span class="hljs-type">char</span> info[<span class="hljs-number">512</span>];<br>    <span class="hljs-built_in">glGetShaderiv</span>(vertex,GL_COMPILE_STATUS,&amp;success);<br>    <span class="hljs-keyword">if</span>(!success)&#123;<br>        <span class="hljs-built_in">glad_glGetShaderInfoLog</span>(vertex,<span class="hljs-number">512</span>,<span class="hljs-literal">NULL</span>,info);<br>        cout&lt;&lt;<span class="hljs-string">&quot;VERTEX SHADER COMPILE ERROR:&quot;</span>&lt;&lt;info&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fragment = <span class="hljs-built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);<br>    <span class="hljs-built_in">glShaderSource</span>(fragment,<span class="hljs-number">1</span>,&amp;fragment_shader,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">glCompileShader</span>(fragment);<br>    <span class="hljs-built_in">glGetShaderiv</span>(fragment,GL_COMPILE_STATUS,&amp;success);<br>    <span class="hljs-keyword">if</span>(!success)&#123;<br>        <span class="hljs-built_in">glad_glGetShaderInfoLog</span>(fragment,<span class="hljs-number">512</span>,<span class="hljs-literal">NULL</span>,info);<br>        cout&lt;&lt;<span class="hljs-string">&quot;FRAGMENT SHADER COMPILE ERROR:&quot;</span>&lt;&lt;info&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> shader_program = <span class="hljs-built_in">glCreateProgram</span>();<br>    <span class="hljs-built_in">glAttachShader</span>(shader_program,vertex);<br>    <span class="hljs-built_in">glAttachShader</span>(shader_program,fragment);<br>    <span class="hljs-built_in">glLinkProgram</span>(shader_program);<br>    <span class="hljs-built_in">glGetProgramiv</span>(shader_program, GL_LINK_STATUS, &amp;success);<br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>        <span class="hljs-built_in">glGetProgramInfoLog</span>(shader_program, <span class="hljs-number">512</span>, <span class="hljs-literal">NULL</span>, info);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&quot;</span> &lt;&lt; info &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-built_in">glDeleteShader</span>(vertex);<br>    <span class="hljs-built_in">glDeleteShader</span>(fragment);<br><br>    <span class="hljs-comment">//定义VAO、VBO、EBO</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VBO;<br>    <span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>,&amp;VBO);<br>    <span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER,VBO);<br>    <span class="hljs-built_in">glBufferData</span>(GL_ARRAY_BUFFER,<span class="hljs-built_in">sizeof</span>(vertices),vertices,GL_STATIC_DRAW);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VAO;<br>    <span class="hljs-built_in">glGenVertexArrays</span>(<span class="hljs-number">1</span>,&amp;VAO);<br>    <span class="hljs-built_in">glBindVertexArray</span>(VAO);<br>    <span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,GL_FLOAT,GL_FALSE,<span class="hljs-number">0</span>,(<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> EBO;<br>    <span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>,&amp;EBO);<br>    <span class="hljs-built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER,EBO);<br>    <span class="hljs-built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER,<span class="hljs-built_in">sizeof</span>(indices),indices,GL_STATIC_DRAW);<br>    <span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">glBindVertexArray</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">glfwWindowShouldClose</span>(window))&#123;<br>        <span class="hljs-built_in">glClearColor</span>(<span class="hljs-number">0.5f</span>,<span class="hljs-number">0.4f</span>,<span class="hljs-number">0.3f</span>,<span class="hljs-number">1.0f</span>);<br>        <span class="hljs-built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<br>        <span class="hljs-built_in">glBindVertexArray</span>(VAO);<br>        <span class="hljs-built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER,EBO);<br>        <span class="hljs-built_in">glUseProgram</span>(shader_program);<br>        <span class="hljs-built_in">glDrawElements</span>(GL_TRIANGLES,<span class="hljs-number">6</span>,GL_UNSIGNED_INT,<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">glBindVertexArray</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER,<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">glfwSwapBuffers</span>(window);<br>        <span class="hljs-built_in">glfwPollEvents</span>();<br>    &#125;<br>    <span class="hljs-built_in">glDeleteBuffers</span>(<span class="hljs-number">1</span>,&amp;VBO);<br>    <span class="hljs-built_in">glDeleteProgram</span>(shader_program);<br>    <span class="hljs-built_in">glDeleteVertexArrays</span>(<span class="hljs-number">1</span>,&amp;VAO);<br>    <span class="hljs-built_in">glfwTerminate</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>图形学</tag>
      
      <tag>OpenGL</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pytorch基础</title>
    <link href="/2024/07/09/Pytorch%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/07/09/Pytorch%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>新领域，新气象。<br>    <span id="more"></span></p><h1 id="PyTorch入门"><a href="#PyTorch入门" class="headerlink" title="PyTorch入门"></a>PyTorch入门</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在PyCharm中配置PyTorch时，需要使用本地解释器而非venv虚拟环境中的解释器，否则会出现torch.cuda.is_available()为False的情况。</p><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="torch-reshape"><a href="#torch-reshape" class="headerlink" title="torch.reshape()"></a>torch.reshape()</h3><p><code>torch.reshape(input, shape)</code>：将输入Tensor变为形状为shape的Tensor</p><h2 id="数据加载"><a href="#数据加载" class="headerlink" title="数据加载"></a>数据加载</h2><h3 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h3><p>用于存储和管理数据的类。</p><p><code>torch.utils.data.Dataset</code>是pytorch提供的抽象类。通过继承此类，可自定义另外的Dataset类。</p><p>通过重写<code>__len()__</code>和<code>__getitem__()</code>方法，可返回数据集的大小和每个数据样本及其Label。</p><p>Dataset类中一般必定存在一个成员变量，该变量是一个列表，存放数据的文件路径。</p><p><code>__getitem__()</code>方法通常返回一个Tuple，元素0为数据内容，元素1为Label。</p><blockquote><p><code>__getitem__()</code>方法无需手动调用，在变量后加[idx]即可。类似于索引访问数组。</p><p>通常，<code>__getitem__()</code>方法根据idx从文件路径列表中取出对应的路径，进而根据路径获取数据本身。</p></blockquote><p>通过运算符<code>+</code>，可以将两个Dataset作为一个列表的两个元素，构成一个2D的更大的Dataset。</p><h3 id="Dataloader"><a href="#Dataloader" class="headerlink" title="Dataloader"></a>Dataloader</h3><p>用于从Dataset中为模型加载数据的类。</p><p><code>torch.utils.data.DataLoader</code>提供了创建DataLoader对象的方法。</p><p><code>DataLoader(dataset, batch_size, shuffle, sampler, batch_sampler, num_workers, drop_last)</code></p><blockquote><p>dataset: 数据集实例。</p><p>batch_size：批处理大小，默认为1.</p><p>shuffle：每次训练过后是否将数据集打乱。</p><p>sampler：</p><p>batch_sampler：</p><p>num_workers：进程数。</p><p>drop_last：数据集大小&#x2F;batch_size除不尽时，余数是否丢弃。</p></blockquote><p><code>DataLoader</code>实例是一个迭代器，每个item都是一个2元素元组。</p><p>元素0是一个列表，包含了batch_size个数据。</p><p>元素1是一个列表，包含了batch_size个Label。</p><h2 id="TensorBoard"><a href="#TensorBoard" class="headerlink" title="TensorBoard"></a>TensorBoard</h2><h3 id="SummaryWriter"><a href="#SummaryWriter" class="headerlink" title="SummaryWriter"></a>SummaryWriter</h3><p><code>from torch.utils.tensorboard import SummarWriter</code></p><p><code> SummaryWriter(str)</code>实例化了一个存储在<code>str</code>文件夹中的<code> SummaryWriter</code>对象。</p><p><code> SummaryWriter</code>类用于在训练过程中向文件写入各类信息。这类信息可以被TensorBoard解析并以可视化的方式呈现。</p><h4 id="add-scalar"><a href="#add-scalar" class="headerlink" title="add_scalar()"></a>add_scalar()</h4><p><code>def add_scalar(self, tag, scalar_value, global_step=None, walltime=None)</code></p><blockquote><p><code>tag</code>是对数据的标识符。</p><p><code>scalar_value</code>是要添加的数据。</p><p><code>global_step</code>是当前训练的步数。</p></blockquote><h4 id="add-image"><a href="#add-image" class="headerlink" title="add_image()"></a>add_image()</h4><p><code>def add_image(self, tag, img_tensor, global_step=None, walltime=None, dataformats=‘CHW’)</code></p><blockquote><p><code>tag</code>是对图片数据的标识符。</p><p><code>img_tensor</code>是图片数据。可以为<code>Tensor</code>、<code>ndarray</code>或<code>string</code>。</p><p>使用<code>np.array(PIL.JpegImageFile)</code>即可将PIL图片转换为<code>ndarray</code>。</p><blockquote><p>此种方式转换的ndarray的shape为（H, W, C），即三个维度分别对应高度、宽度和通道。</p><p>因此，此时add_image的dataformats参数应当为‘HWC’。</p></blockquote><p>也可用torchvision.transforms.ToTensor()将PIL图片转化为Tensor。</p><p>也可用cv.imread将PIL图片转化为CHW的ndarray。</p></blockquote><h4 id="add-graph"><a href="#add-graph" class="headerlink" title="add_graph()"></a>add_graph()</h4><p><code>add_graph(model, input_to_model=None, verbose=False)</code></p><h2 id="Transforms"><a href="#Transforms" class="headerlink" title="Transforms"></a>Transforms</h2><p><code>from torchvision import transforms</code></p><p><code>transforms</code>用于对图片数据进行变换。该模块内置了若干工具类，</p><h3 id="Compose"><a href="#Compose" class="headerlink" title="Compose()"></a><code>Compose()</code></h3><p><code>Compose(list of transforms object)</code>用于组合多个transforms对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">operation = transforms.Compose([transforms.CenterCrop(<span class="hljs-number">10</span>), transforms.ToTensor()])<br><span class="hljs-comment"># 对图片进行operation操作时，先将其中心裁剪，再将其转换为Tensor对象</span><br></code></pre></td></tr></table></figure><h3 id="ToTensor"><a href="#ToTensor" class="headerlink" title="ToTensor()"></a><code>ToTensor()</code></h3><p><code>ToTensor()</code>用于将对象转换为<code>Tensor</code>对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用PIL打开本地图片，使用ToTensor转换为Tensor对象，再用Tensorboard写入事件文件。</span><br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms<br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><br>img = Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">r&quot;data/img/1.jpg&quot;</span>)<br>totensor_operation = transforms.ToTensor()<br>img_tensor = totensor_operation(img)<br>writer = SummaryWriter(<span class="hljs-string">&quot;test&quot;</span>)<br>writer.add_image(<span class="hljs-string">&quot;测试图片&quot;</span>,img_tensor)<br>writer.close()<br></code></pre></td></tr></table></figure><h3 id="ToPILImage"><a href="#ToPILImage" class="headerlink" title="ToPILImage()"></a><code>ToPILImage()</code></h3><p>将<code>ndarray</code>或<code>Tensor</code>对象转换为PILImage。</p><h3 id="Normalize"><a href="#Normalize" class="headerlink" title="Normalize()"></a><code>Normalize()</code></h3><p>使用z-score法将Tensor对象标准化。</p><p><code>transforms.Normalize(mean=list, std=list)</code></p><blockquote><p>对于mean和std，图片有几个通道，它们就是有几个元素的list。</p><p>list各元素的值需要对数据集中的每个元素的每个通道计算得出。</p></blockquote><p>输出：(原始值-均值)&#x2F;标准差</p><p>作用：将图像的数据分布转换为标准正态分布。</p><p><img src="https://yoi-note.oss-cn-chengdu.aliyuncs.com/Image/202404271416967.png" alt="image-20240427141609922"></p><h3 id="Resize"><a href="#Resize" class="headerlink" title="Resize()"></a><code>Resize()</code></h3><p>将给定的PILImage变换至指定尺寸。</p><p><code>transforms.Resize(size)</code>实例化了一个Resize操作对象。</p><blockquote><p>当size为2元素列表时，第一个元素是高，第二个元素是宽。</p><p>当size为int时，图片更小的边将被缩放至int。</p></blockquote><p><code>transforms.Resize(img)</code>用于将已实例化的缩放操作应用于PILImage。接收的参数可为PILImage，也可为Tensor。</p><h3 id="RandomCrop"><a href="#RandomCrop" class="headerlink" title="RandomCrop()"></a><code>RandomCrop()</code></h3><p>根据给定的size随机裁剪原图片。</p><p><code>transforms.RandomCrop(size)</code>实例化了一个RandomCrop对象。</p><blockquote><p>可选参数：padding：int，2元素列表或4元素列表。分别对应：</p><ul><li>在图片四周添加int像素的间隔。</li><li>在图片左右添加[0]像素间隔，上下添加[1]像素间隔。</li><li>在图片上下左右分别添加[0]、[1]、[2]、[3]像素间隔。</li></ul><p>pad_if_needed：布尔值，当裁剪大小大于图片大小时，自动添加padding。</p><p>fill：int或3元素列表，用于填充padding的像素色。分别对应：RGB（int, int, int）和RGB（r, g, b)</p></blockquote><p><code>transforms.RandomCrop(img)</code>用于执行裁剪操作。</p><h2 id="torchvision数据集"><a href="#torchvision数据集" class="headerlink" title="torchvision数据集"></a>torchvision数据集</h2><p>以<code>CIFAR10</code>数据集为例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torchvision<br><br>train_set = torchvision.datasets.CIFAR10(root=<span class="hljs-string">&quot;dataset&quot;</span>, train=<span class="hljs-literal">True</span>, download=<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># root为存放数据集的根目录;train为是否训练集;download为是否从网络下载数据集。</span><br>test_set = torchvision.datasets.CIFAR10(root=<span class="hljs-string">&quot;dataset&quot;</span>, train=<span class="hljs-literal">False</span>, download=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><blockquote><p>除上述属性外，还有：</p><p><code>transform</code>属性：可传入<code>transforms</code>函数，对数据进行预处理。</p></blockquote><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><h2 id="nn-Module"><a href="#nn-Module" class="headerlink" title="nn.Module"></a><code>nn.Module</code></h2><p><code>nn.Module</code>是所有神经网络的基类。</p><p>自定义一个神经网络类，首先要做的便是继承<code>nn.Module</code>，随后实现<code>__init__()</code>和<code>forward()</code>函数。</p><p>实现<code>__init__()</code>函数时，首先要调用<code>super().__init__()</code>。其中classname为自定义类的类名。</p><p><code>forward()</code>函数实现了前向传播。它接收一个<code>x</code>参数输入，对<code>x</code>进行一系列处理之后返回。</p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyNetwork</span>(nn.Module):<br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>     <span class="hljs-built_in">super</span>(MyNetwork, self).__init__()<br>     <span class="hljs-comment"># 将各层操作作为变量存储</span><br>     self.layerfunction1 = nn.Conv2d(...)<br>     ...<br><br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>     output = self.xxxfunction(x)<br>     <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure></blockquote><h2 id="nn-Sequential"><a href="#nn-Sequential" class="headerlink" title="nn.Sequential"></a><code>nn.Sequential</code></h2><p><code>Sequential</code>用于保存一系列层操作，如卷积、非线性激活、池化等。类似于Transforms的Compose。</p><p><code>model = nn.Sequential(nn.Conv2d(1,20,5),nn.ReLU(),nn.Conv2d(20,64,5),nn.ReLu)</code></p><blockquote><p>输入x可省略。</p></blockquote><h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><p>卷积（Convolution）是让两个函数经过变换得到第三个函数的过程。</p><p><img src="https://yoi-note.oss-cn-chengdu.aliyuncs.com/Image/202404292040281.png" alt="image-20240429204022080"></p><p><code>torch.nn.function</code>模块中，提供了从1D到3D数据的卷积函数：<code>conv1d()</code>、<code>conv2d</code>和<code>conv3d</code>。</p><p>以<code>conv2d()</code>为例：</p><p><code>conv2d(input, weight, bias=None, stride=1, padding=0, dilation=1, groups=1) -&gt; Tensor</code></p><blockquote><p><code>input</code>为输入的Tensor。在CV中，这个Tensor一般是2DTensor，是Image经过ToTensor()变换的结果。</p><blockquote><p>对于input的Tensor，其形状必须满足<code>(minibatch, in_channels, iH, iW)</code></p><p><code>minibatch</code>是<code>DataLoader</code>的<code>batch_size</code>。</p><p><code>in_channels</code>是图片的通道数。</p><p><code>iH</code>、<code>iW</code>分别是图片的高和宽。</p></blockquote><p><code>weight</code>权重，又叫卷积核。</p><blockquote><img src="https://yoi-note.oss-cn-chengdu.aliyuncs.com/Image/202404292143205.png" alt="image-20240429214304139" style="zoom:50%;" /><p>卷积核就像一个遮罩，对输入图像的局部进行处理。卷积核上元素值的不同，卷积结果就不同。元素值就是一个个权重。</p><p>权重的形状必须满足<code>(out_channels, in_channels/groups, kH, kW)</code></p><p><code>out_channels</code>是输出图片的通道数。</p></blockquote><p><code>bias</code>偏置。</p><p><code>stride</code>步进。直观来讲，步进是卷积核在输入图像上方每次移动的像素数。</p><blockquote><p>步进既可以是一个数，也可以是元组(sH, sW)。前者是横向移动的元素数，后者是纵向移动的元素数。</p></blockquote><p><code>padding</code>间隔。直观来讲，对输入图片的边缘进行填充，便于对边缘像素进行卷积处理。</p><blockquote><p>间隔既可以是一个数，也可以是元组(padH, padW)。前者是横向填充的元素数，后者是纵向填充的元素数。</p></blockquote><p><code>dilation</code></p><p><code>groups</code></p></blockquote><h2 id="结构-层"><a href="#结构-层" class="headerlink" title="结构&#x2F;层"></a>结构&#x2F;层</h2><p>可以把每个函数看作一个层。</p><h3 id="卷积层（Convolution-Layer）"><a href="#卷积层（Convolution-Layer）" class="headerlink" title="卷积层（Convolution Layer）"></a>卷积层（Convolution Layer）</h3><p><code>torch.nn</code>提供了<code>torch.nn.function</code>中各功能的简化版本。</p><p><code>Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True, padding_mode=‘zeros’)</code></p><blockquote><p><a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md">conv_arithmetic&#x2F;README.md at master · vdumoulin&#x2F;conv_arithmetic (github.com)</a></p><p>in_channels：输入通道数</p><p>out_channels：输出通道数</p><blockquote><p>即卷积核个数。</p></blockquote><p>kernel_size：卷积核尺寸。可变量，会在训练过程中自行改变。</p><p>stride：步进数</p><p>padding：边缘补充</p><p>dilation：让卷积核的各元素之间间隔一定距离。用于空洞卷积。</p><blockquote> <img src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/dilation.gif" alt="img" style="zoom: 33%;" /></blockquote><p>groups：用于分组卷积</p><p>bias：偏置。</p></blockquote><h3 id="池化层（Pooling-Layer）"><a href="#池化层（Pooling-Layer）" class="headerlink" title="池化层（Pooling Layer）"></a>池化层（Pooling Layer）</h3><p>池化层将一个窗口内的所有信息浓缩为一个输出。它一般在卷积后进行，输入和输出的通道相同，不可改变。因此，输出尺寸会减小，参数减小，助于减少过拟合、提高性能。</p><blockquote><p>卷积核平移的过程，可看作滑动窗口过程。卷积核就是窗口。</p></blockquote><p>对于最大池化（Max Pooling）操作，它取一个窗口内最大的值输出，然后步进。</p><p><code>MaxPool2d(kernel_size, stride=None, padding=0*, dilation=1*, return_indices=False*, ceil_mode=False)</code></p><blockquote><p>return_indices：</p><p>ceil_mode：True时，使用ceil模式（允许出界）；否则使用floor模式（出界池化丢弃）。</p><p>stride：<strong>池化核的步长默认为核大小</strong></p></blockquote><p>平均池化（Mean Pooling）操作计算窗口内平均值输出，然后步进。</p><h3 id="填充层（Padding-Layer）"><a href="#填充层（Padding-Layer）" class="headerlink" title="填充层（Padding Layer）"></a>填充层（Padding Layer）</h3><p>类似于卷积和池化操作中的<code>Padding</code>参数。不同的是，<code>Padding</code>只能填充0，而填充层可以填充其他常数。</p><h3 id="非线性激活（Non-linear-Activations）"><a href="#非线性激活（Non-linear-Activations）" class="headerlink" title="非线性激活（Non-linear Activations）"></a>非线性激活（Non-linear Activations）</h3><h4 id="线性整流函数（ReLU）"><a href="#线性整流函数（ReLU）" class="headerlink" title="线性整流函数（ReLU）"></a>线性整流函数（ReLU）</h4><p><code>torch.nn.ReLU(x)</code>：等效于<code>max(0,x)</code>。</p><blockquote><p><code>inplace</code>参数（bool）：为True则修改传入值；否则传出新值，传入值不变。</p></blockquote><h4 id="Sigmoid函数"><a href="#Sigmoid函数" class="headerlink" title="Sigmoid函数"></a>Sigmoid函数</h4><p><code>torch.nn.Sigmoid(x)</code>：等效于：<code>1/(1+exp(-x))</code>。</p><h3 id="正则化层（Normalization-Layer）"><a href="#正则化层（Normalization-Layer）" class="headerlink" title="正则化层（Normalization Layer）"></a>正则化层（Normalization Layer）</h3><p>用于提高网络性能。</p><p><a href="https://blog.csdn.net/qq_41915623/article/details/125984629">pytorch中对BatchNorm2d()函数的理解-CSDN博客</a></p><p><code>torch.nn.BatchNorm2d(num_features, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, device=None, dtype=None)</code></p><blockquote><p>num_features：通道数。</p><p>eps：稳定值，避免分母为0，默认为1e-5。</p><p>momentum：将历史batch的均值与方差的影响延续到当前batch。</p><p>affine：True时，给定可以学习的系数矩阵Gamma和Beta。</p></blockquote><h3 id="线性层（Linear-Layer）"><a href="#线性层（Linear-Layer）" class="headerlink" title="线性层（Linear Layer）"></a>线性层（Linear Layer）</h3><p><code>torch.nn.Linear(in_features, out_features, bias=True)</code></p><p>对输入施加线性变换：<img src="https://yoi-note.oss-cn-chengdu.aliyuncs.com/Image/202405021536109.png" alt="image-20240502153650043" style="zoom:50%;" /></p><blockquote><p><strong>feature</strong>：特征。对事物进行分类或识别的本质就是提取特征。</p><p>在神经网络中，in_features指的是输入的数组。out_features则反之。</p><p>在Linear函数中，前两个参数分别是输入数组的元素个数和输出数组的元素个数。</p></blockquote><h3 id="丢弃层（Dropout-Layer）"><a href="#丢弃层（Dropout-Layer）" class="headerlink" title="丢弃层（Dropout Layer）"></a>丢弃层（Dropout Layer）</h3><p>防止过拟合。</p><p><code>torch.nn.Dropout2d(p=0.5, inplace=False)</code></p><p>随机将某些元素按p的概率设为0。</p><h3 id="嵌入层（Embedding-Layer）"><a href="#嵌入层（Embedding-Layer）" class="headerlink" title="嵌入层（Embedding Layer）"></a>嵌入层（Embedding Layer）</h3><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>损失函数（Loss Function）用于衡量实际输出与预期输出之间的差距，并用误差值指导模型进行进一步训练学习（即反向传播）。</p><h3 id="L1Loss"><a href="#L1Loss" class="headerlink" title="L1Loss()"></a><code>L1Loss()</code></h3><p><code>torch.nn.L1Loss(input, tartget, reduction=&#39;mean&#39;)</code></p><blockquote><p>input和target的形状为（*, *)。输出一个标量。</p><p>reduction：处理方式。‘mean’则将每个元素的MAE相加并处以元素数量。‘sum’只相加。</p></blockquote><p>比较每个元素的平均绝对误差（Mean Absolute Error, MAE）。</p><blockquote><p>output &#x3D; (|x - x’|+|y - y’| + …)&#x2F;N</p></blockquote><h3 id="SmoothL1Loss"><a href="#SmoothL1Loss" class="headerlink" title="SmoothL1Loss()"></a><code>SmoothL1Loss()</code></h3><img src="https://yoi-note.oss-cn-chengdu.aliyuncs.com/Image/202405031327320.png" alt="image-20240503132740254" style="zoom: 67%;" /><p><code>torch.nn.SmoothL1Loss(reduction=&#39;mean&#39;, beta=1.0)</code></p><p>平滑版的L1Loss。</p><p>当MAE小于1时，返回MSE的0.5倍；否则返回MAE-0.5。结合了L1和MSE的部分优点，适合多数情况。</p><h3 id="MSELoss"><a href="#MSELoss" class="headerlink" title="MSELoss()"></a><code>MSELoss()</code></h3><p><code>torch.nn.MSELoss(reduction=&#39;mean&#39;)</code></p><blockquote><p>input和target的形状为（*, *)。输出一个标量。</p></blockquote><p>比较每个元素的均方差。</p><blockquote><p>output &#x3D; (|x - x’|^2+|y - y’|^2 + …)&#x2F;N</p></blockquote><h3 id="CrossEntropyLoss"><a href="#CrossEntropyLoss" class="headerlink" title="CrossEntropyLoss()"></a><code>CrossEntropyLoss()</code></h3><p><code>torch.nn.CrossEntropyLoss(weight=None, ignore_index=-100, reduction=&#39;mean&#39;, label_smoothing=0.0)</code></p><p>比较预期输出和实际输出的交叉熵。在分类问题中常用。</p><img src="https://yoi-note.oss-cn-chengdu.aliyuncs.com/Image/202405031400362.png" alt="image-20240503140023311" style="zoom:50%;" /><blockquote><p>input的形状需要是（N, C）或(C, C)，其中N为batch_size，C为分类的类别数。</p></blockquote><h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><p> 对损失函数的结果调用<code>backward()</code>子方法即可。</p><p>反向传播用于计算损失函数梯度。得到梯度以后，使用优化器对参数进行更新。</p><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p><a href="https://pytorch.org/docs/main/optim.html">torch.optim — PyTorch main documentation</a></p><p>以<code>torch.optim.SGD()</code>为例：</p><ul><li>实例化优化器对象：<code>optimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.9)</code><ul><li>model.parameters()：nn.Module的parameters()函数。</li><li>lr：学习速率。一般训练前期设置为大数值，训练后期设置为小数值。</li></ul></li><li>每次取数据都要设置<code>optimizer.zero_grad()</code>。</li><li>进行反向传播后，调用<code>optimizer.step()</code></li></ul><p>对dataset的每一次遍历就是一次训练过程，称为一个epoch。</p><h2 id="现有网络"><a href="#现有网络" class="headerlink" title="现有网络"></a>现有网络</h2><p>以<code>vgg16</code>为例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">vgg16_pretrained = torchvision.models.vgg16(VGG16_Weights.IMAGENET1K_FEATURES) <span class="hljs-comment"># 下载网络并赋予权重</span><br>vgg16.add_module(<span class="hljs-string">&quot;add_linear&quot;</span>, nn.Linear(<span class="hljs-number">1000</span>, <span class="hljs-number">10</span>)) <span class="hljs-comment"># 添加自己的module</span><br>vgg16.classifier[<span class="hljs-number">7</span>] = nn.Linear(<span class="hljs-number">4096</span>, <span class="hljs-number">10</span>) <span class="hljs-comment"># 修改module</span><br></code></pre></td></tr></table></figure><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><p>方式一：<code>torch.save(model_var_name, path)</code>：将模型结构以及参数保存为文件。</p><blockquote><p>注意path添加后缀，通常为.pth。</p></blockquote><p>方式二：<code>torch.save(model_var_name.state_dict(), path)</code>：仅保存模型参数（推荐）。</p><blockquote><p>注意path添加后缀，通常为.pkl。</p></blockquote><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p><code>torch.load(path)</code>：对应保存方式一。</p><p><code>model_var_name.load_state_dict()</code>：对应保存方式二。</p><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><h4 id="定义网络结构"><a href="#定义网络结构" class="headerlink" title="定义网络结构"></a>定义网络结构</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Network.py</span><br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyNetwork</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(MyNetwork, self).__init__()<br>        self.model_layers = nn.Sequential(<br>        nn.XXX(...)<br>        nn.XXX(...)<br>            ...<br>        )<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, <span class="hljs-built_in">input</span></span>):<br>        output = self.model_layers(<span class="hljs-built_in">input</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">input</span><br>    <br>    <br><span class="hljs-keyword">if</span>(__name__ == <span class="hljs-string">&quot;__main__&quot;</span>):<br>    mynetwork = MyNetwork()<br>    <span class="hljs-built_in">input</span> = xxx<br>    output = mynetwork(<span class="hljs-built_in">input</span>)<br>    <span class="hljs-built_in">print</span>(output.shape)<br></code></pre></td></tr></table></figure><h4 id="获取、读取数据集-训练"><a href="#获取、读取数据集-训练" class="headerlink" title="获取、读取数据集 | 训练"></a>获取、读取数据集 | 训练</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> datasets, transforms<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn, optim<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">from</span> Network <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 获取数据集并读取</span><br>train_dataset = datasets.CIFAR10(root=<span class="hljs-string">&quot;dataset_root&quot;</span>, train=<span class="hljs-literal">True</span>, transform=transforms.ToTensor(), download=<span class="hljs-literal">True</span>)<br>loader = DataLoader(train_dataset, shuffle=<span class="hljs-literal">True</span>, batch_size = <span class="hljs-number">64</span>, drop_last=<span class="hljs-literal">False</span>)<br>test_dataset = datasets.CIFAR10(root=<span class="hljs-string">&quot;dataset_root&quot;</span>, download=<span class="hljs-literal">True</span>, train=<span class="hljs-literal">False</span>, transform=transforms.ToTensor())<br>test_dataset_len = <span class="hljs-built_in">len</span>(test_dataset)<br>test_loader = DataLoader(test_dataset, shuffle=<span class="hljs-literal">True</span>, drop_last=<span class="hljs-literal">False</span>)<br>total_test_loss = <span class="hljs-number">0</span><br><span class="hljs-comment"># 实例化网络</span><br>network = MyNetwork()<br>loss = nn.CrossEntropyLoss()<br>optimizer = optim.SGD(network.parameters(), lr=<span class="hljs-number">0.01</span>)<br><span class="hljs-comment"># 定义训练参数</span><br>total_train_step = <span class="hljs-number">0</span><br>epoch = <span class="hljs-number">20</span><br>total_test_step = <span class="hljs-number">0</span><br><span class="hljs-comment"># 开始训练</span><br>mynetwork.train()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epoch):<br>    running_loss = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> imgs, targets <span class="hljs-keyword">in</span> loader:<br>    optimizer.zero_grad()<br>    output = network(imgs)<br>    loss_val = loss(output, targets) <br>    loss_val.backward()<br>    optimizer.step()<br>     total_train_step += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span>(total_train_step % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前训练次数：&#123;&#125; | 总训练次数：&#123;&#125; | 本次训练损失值：&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i, total_train_step, loss_val))<br></code></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 接上文</span><br>    mynetwork.<span class="hljs-built_in">eval</span>()<br>    correct_num = <span class="hljs-number">0</span><br><span class="hljs-keyword">with</span> torch.nograd():<br>   <span class="hljs-keyword">for</span> imgs, targets <span class="hljs-keyword">in</span> test_loader:<br>        output = mynetwork(imgs)<br>           correct_num += (targets == output.argmax(<span class="hljs-number">1</span>)).<span class="hljs-built_in">sum</span>()<br>            correct_num = correct_num.item()<br>        loss_val = loss(output, targets)<br>        total_test_loss += loss_val<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;整体损失率：&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(total_test_loss))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;整体正确率：&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">float</span>(correct_num/test_dataset_len)))<br>    torch.save(mynetwork, <span class="hljs-string">&quot;network&#123;&#125;.pth&quot;</span>.<span class="hljs-built_in">format</span>(i))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>人工智能</tag>
      
      <tag>Python</tag>
      
      <tag>Pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字化皮影戏交互系统开发日志——沙盘模块①</title>
    <link href="/2024/01/26/%E6%95%B0%E5%AD%97%E5%8C%96%E7%9A%AE%E5%BD%B1%E6%88%8F%E4%BA%A4%E4%BA%92%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%E2%80%94%E2%80%94%E6%B2%99%E7%9B%98%E6%A8%A1%E5%9D%97%E2%91%A0/"/>
    <url>/2024/01/26/%E6%95%B0%E5%AD%97%E5%8C%96%E7%9A%AE%E5%BD%B1%E6%88%8F%E4%BA%A4%E4%BA%92%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%E2%80%94%E2%80%94%E6%B2%99%E7%9B%98%E6%A8%A1%E5%9D%97%E2%91%A0/</url>
    
    <content type="html"><![CDATA[<p>从零开始的一次尝试。<br>    <span id="more"></span></p><h2 id="初期策划"><a href="#初期策划" class="headerlink" title="初期策划"></a>初期策划</h2><p>既然名为“数字皮影戏科普交互系统”，首要需求便是在程序内复原实物皮影戏，包括视觉观感、操作方式、音效氛围、演绎内容等。</p><p>策划期间，需要着重考虑可行性。笔者作为技术人员，将技术可行性作为策划期间的首要考虑因素。</p><p><img src="https://yoi-note.oss-cn-chengdu.aliyuncs.com/Image/202401261814028.png" alt="image-20240126181415934"></p><h3 id="基本可行性"><a href="#基本可行性" class="headerlink" title="基本可行性"></a>基本可行性</h3><p>上面是一张实物皮影戏的视频截图。可以观察到，实物皮影戏在视觉上与传统2D平面游戏的区别在于：</p><ul><li>“远虚近实”：元素离幕布越远，色调越偏向黑色，并且越来越淡，同时整体越来越大。</li><li>位于幕后：所有元素在实物皮影戏中均位于幕布之后，通过投影在另一端呈现。</li></ul><p>“远虚近实”效果涉及到Sprite的两方面：大小与颜色。前者（Sprite的大小随距离变化）只需编写脚本动态修改Sprite的localScale即可。后者（同时修改材质的颜色与透明度）同样可以使用脚本实现。但为了提前学习图形学知识，笔者这里选择编写Shader。</p><p><img src="https://yoi-note.oss-cn-chengdu.aliyuncs.com/Image/202401261822658.png" alt="image-20240126182248623"></p><p>上图展示了Shader的编写思路。材质附着在影人上时，通过_WorldSpaceCameraPos可得到L2。保持L1不变（一般是实物皮影戏里的摄像机也不会移动过），就可计算得到L3。把L3作为变量加入Shader的frag函数中，即可让材质片元随L3的变化而变化。因此，技术上可行。</p><h3 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h3><p>最主要的视觉视效复刻是完全可行的。接下来考虑程序的整体框架。</p><p><img src="https://yoi-note.oss-cn-chengdu.aliyuncs.com/Image/202401261826536.png" alt="image-20240126182620479"></p><h4 id="沙盘模块"><a href="#沙盘模块" class="headerlink" title="沙盘模块"></a>沙盘模块</h4><p>对于影人，各个部件就是骨骼，部件之间的转轴就是关节。现实中表演者是用几根棍子拖动影人的主要关节来使其移动的，游戏里我们可以用鼠标拖动模拟棍子拖动。对于没有棍子控制的部位，一般使用重力+惯性的方式使其移动。在Unity里，这意味着它们要附着刚体与碰撞体组件。</p><p>如果先不考虑影人的自动移动与表演，单纯把影人作为一个2D布娃娃来看的话，只需要用铰链关节把各部位连接起来就可以了。技术可行。此外，2D布娃娃也可以作为系统的一部分，让用户拖着这个布娃娃在空白的场景里自由的玩耍。这就是沙盘模块。</p><h4 id="戏剧播放模块"><a href="#戏剧播放模块" class="headerlink" title="戏剧播放模块"></a>戏剧播放模块</h4><p>既然是复原实物皮影戏，那程序肯定得能播放经典的皮影戏剧。直接放视频未免显得太敷衍，我们要搭建一套完善的皮影戏剧播放模块。在实现了沙盘模块的基础上，我们有两个选择：</p><ul><li>不沿用2D布娃娃系统，改用2D骨骼动画。这种方式比较困难，因为皮影剧目往往持续十分钟以上，如果用K帧的方式做动画的话工作量太大。</li><li>沿用2D布娃娃系统，想办法借此制作动画。</li></ul><p>一番权衡利弊，还是在沙盘模式的基础上制作剧目动画比较好。而且如果给沙盘模式加入录制功能的话，玩家也可以自己录剧目自己看，也不失为一种乐趣。</p><p>就像视频是由一帧帧图片构成的一样，数字皮影剧目里，“一帧”是由场景内众多元素的位置信息构成的。只要每隔一段极短的时间，把时间信息与当前帧所有元素的位置信息写入文件，就可以完成“剧目”的记录。播放时，读取文件即可播放剧目。</p><h4 id="图鉴模块"><a href="#图鉴模块" class="headerlink" title="图鉴模块"></a>图鉴模块</h4><p>作为科普应用，我们的系统自然也是得有图鉴模块的。图鉴模块就比较简单，一个滑动窗口+若干UI元素就完事了。当然，要做的花哨的话，也可以模仿老滚5的加载界面，点一个UI单元，右边就会呈现它的模型。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>沙盘模块做完以后，做其他模块都会比较方便，所以笔者首先进行沙盘模块的编码。</p><h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><h4 id="拖拽与铰链关节的配合"><a href="#拖拽与铰链关节的配合" class="headerlink" title="拖拽与铰链关节的配合"></a>拖拽与铰链关节的配合</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnMouseDown</span>()</span><br>&#123;<br>    <span class="hljs-comment">//将物体坐标转换为屏幕坐标，获取Z轴长度</span><br>    _screenPoint = Camera.main.WorldToScreenPoint(gameObject.transform.position);<br>    <span class="hljs-comment">//计算物体中心点和鼠标触发点坐标得差值</span><br>    _offset = gameObject.transform.position - Camera.main.ScreenToWorldPoint(<span class="hljs-keyword">new</span> Vector3(Input.mousePosition.x, Input.mousePosition.y, _screenPoint.z));<br>&#125;<br></code></pre></td></tr></table></figure><p>OnMouseDrag()事件函数本质上是改变Transform的position，并不是对刚体产生影响，而铰链关节的相互作用是基于刚体的。因此，使用OnMouseDrag()编写的拖拽功能，在生效时，整个影人都是静止的，完全不存在惯性。</p><p>可能是笔者才疏学浅，到目前为止没听说过基于刚体的拖拽实现。因此，我们要在保留OnMouseDrag拖拽的同时，对刚体进行处理。</p><p>如果按照现实物理的思路，应当为对象手动添加“与拖拽相关联的惯性”。在OnMouseDrag()中记录鼠标移动增量，并以此作为速度。通过Update+Lerp实现对象Rigidbody.velocity不断向鼠标移动速度逼近，以此模仿惯性。然而，这种方式实现起来还是比较困难，同时也比较耗性能。</p><p>惯性在含有铰链关节的对象上最显著的表现是：对象物体向一端加速移动时，铰链连接着的另一物体会呈现“向反方向移动”的表现。那么，是不是只要在拖动父物体时，给子物体施加反方向速度，就能模拟惯性呢？</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnMouseDrag</span>()</span>&#123;<br>    Vector3 _prevPosition = _curPosition;<span class="hljs-comment">//记录此前鼠标位置</span><br>    _curScreenPoint = <span class="hljs-keyword">new</span> Vector3(Input.mousePosition.x, Input.mousePosition.y, _screenPoint.z);<br>_curPosition = Camera.main.ScreenToWorldPoint(_curScreenPoint) + _offset;<span class="hljs-comment">//坐标系转换</span><br>_velocity = InertiiaPara*(_curPosition - _prevPosition);<span class="hljs-comment">//计算速度，其中InertiiaPara表示速度系数，越大，对反方向施加的速度就越大</span><br>transform.position = _curPosition;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果非常好。</p><h4 id="多相机混合"><a href="#多相机混合" class="headerlink" title="多相机混合"></a>多相机混合</h4><p>第一次用著名Unity插件Top-Down Engine时，单独UI Camera渲染UI的实现方式深深震撼了Unity初学者的心。不管怎么说，这个项目笔者都要用上这种方式。</p><p>新建一个Camera，把Audio Listener去掉（<strong>场景内通常只存在一个Audio Listener，一般附着在Main Camera上</strong>），把它的投影方式设置为正交（因为UI不需要透视）。</p><p>注意，Clear Flags要设置为Depth Only。这里的Depth指的是相机的Depth，Depth越高的相机渲染次序越靠后。即便UI位于一大堆主相机看着的Opaque物体之后，只要UI Camera的Depth大于Main Camera，UI就能好好显示。网上有个设置UICamera的教材让把Clear Flag设置为Dont Clear，属实误人子弟。</p><p>Culling Mask设置为UI，这样UI Camera就不会渲染其他不小心跑进来的东西。</p><h4 id="代码控制Scale"><a href="#代码控制Scale" class="headerlink" title="代码控制Scale"></a>代码控制Scale</h4><p>对于2D Sprite，调整Scale时，变化的基点是Pivot。例如，Pivot位于中心的正方形，Scale等比例增大时，其四条边均匀远离中心。Pivot位于下边中点的正方形，Scale等比例增大时，下边的世界坐标（这么说其实不严谨，理解就行）不会发生变化。</p><p>通过改变Sprite的Pivot（在Sprite Editor中进行），可以避免例如位于屏幕边缘的Sprite调整Scale后超出屏幕范围的情况。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数字皮影戏系统</tag>
      
      <tag>开发日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
