<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LearnOpenGL学习笔记（三）</title>
    <link href="/2024/07/13/LearnOpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2024/07/13/LearnOpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>快乐的一天。<br>    <span id="more"></span></p><h1 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h1><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>$$<br>\begin{bmatrix} \color{red}{S_1} &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}0 \ \color{green}0 &amp; \color{green}{S_2} &amp; \color{green}0 &amp; \color{green}0 \ \color{blue}0 &amp; \color{blue}0 &amp; \color{blue}{S_3} &amp; \color{blue}0 \ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} \cdot \begin{pmatrix} x \ y \ z \ 1 \end{pmatrix} &#x3D; \begin{pmatrix} \color{red}{S_1} \cdot x \ \color{green}{S_2} \cdot y \ \color{blue}{S_3} \cdot z \ 1 \end{pmatrix}<br>$$</p><blockquote><p>三维空间的变换矩阵一般都是四维矩阵。w分量与具体变换无关。</p></blockquote><h2 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h2><p>$$<br>\begin{bmatrix}  \color{red}1 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}{T_x} \ \color{green}0 &amp; \color{green}1 &amp; \color{green}0 &amp; \color{green}{T_y} \ \color{blue}0 &amp; \color{blue}0 &amp; \color{blue}1 &amp; \color{blue}{T_z} \ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} \cdot \begin{pmatrix} x \ y \ z \ 1 \end{pmatrix} &#x3D; \begin{pmatrix} x + \color{red}{T_x} \ y + \color{green}{T_y} \ z + \color{blue}{T_z} \ 1 \end{pmatrix}<br>$$</p><blockquote><p>可以看到，因为有了w分量，所以才能实现位移。</p><p>w分量被称为<strong>齐次坐标</strong>（Homogeneous Coordinates）。齐次坐标为0的向量被称为方向向量，它无法被位移。</p></blockquote><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>$$<br>\begin{bmatrix} \color{red}1 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}0 \ \color{green}0 &amp; \color{green}{\cos \theta} &amp; - \color{green}{\sin \theta} &amp; \color{green}0 \ \color{blue}0 &amp; \color{blue}{\sin \theta} &amp; \color{blue}{\cos \theta} &amp; \color{blue}0 \ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} \cdot \begin{pmatrix} x \ y \ z \ 1 \end{pmatrix} &#x3D; \begin{pmatrix} x \ \color{green}{\cos \theta} \cdot y - \color{green}{\sin \theta} \cdot z \ \color{blue}{\sin \theta} \cdot y + \color{blue}{\cos \theta} \cdot z \ 1 \end{pmatrix}<br>$$</p><p>$$<br>\begin{bmatrix} \color{red}{\cos \theta} &amp; \color{red}0 &amp; \color{red}{\sin \theta} &amp; \color{red}0 \ \color{green}0 &amp; \color{green}1 &amp; \color{green}0 &amp; \color{green}0 \ - \color{blue}{\sin \theta} &amp; \color{blue}0 &amp; \color{blue}{\cos \theta} &amp; \color{blue}0 \ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} \cdot \begin{pmatrix} x \ y \ z \ 1 \end{pmatrix} &#x3D; \begin{pmatrix} \color{red}{\cos \theta} \cdot x + \color{red}{\sin \theta} \cdot z \ y \ - \color{blue}{\sin \theta} \cdot x + \color{blue}{\cos \theta} \cdot z \ 1 \end{pmatrix}<br>$$</p><p>$$<br>\begin{bmatrix} \color{red}{\cos \theta} &amp; - \color{red}{\sin \theta} &amp; \color{red}0 &amp; \color{red}0 \ \color{green}{\sin \theta} &amp; \color{green}{\cos \theta} &amp; \color{green}0 &amp; \color{green}0 \ \color{blue}0 &amp; \color{blue}0 &amp; \color{blue}1 &amp; \color{blue}0 \ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} \cdot \begin{pmatrix} x \ y \ z \ 1 \end{pmatrix} &#x3D; \begin{pmatrix} \color{red}{\cos \theta} \cdot x - \color{red}{\sin \theta} \cdot y  \ \color{green}{\sin \theta} \cdot x + \color{green}{\cos \theta} \cdot y \ z \ 1 \end{pmatrix}<br>$$</p><p>上面三个矩阵分别是以x、y、z轴旋转θ°的旋转矩阵。</p><p>这些矩阵复合可能会导致万向节死锁。沿任意旋转轴旋转θ°的旋转矩阵如下：<br>$$<br>\begin{bmatrix} \cos \theta + \color{red}{R_x}^2(1 - \cos \theta) &amp; \color{red}{R_x}\color{green}{R_y}(1 - \cos \theta) - \color{blue}{R_z} \sin \theta &amp; \color{red}{R_x}\color{blue}{R_z}(1 - \cos \theta) + \color{green}{R_y} \sin \theta &amp; 0 \ \color{green}{R_y}\color{red}{R_x} (1 - \cos \theta) + \color{blue}{R_z} \sin \theta &amp; \cos \theta + \color{green}{R_y}^2(1 - \cos \theta) &amp; \color{green}{R_y}\color{blue}{R_z}(1 - \cos \theta) - \color{red}{R_x} \sin \theta &amp; 0 \ \color{blue}{R_z}\color{red}{R_x}(1 - \cos \theta) - \color{green}{R_y} \sin \theta &amp; \color{blue}{R_z}\color{green}{R_y}(1 - \cos \theta) + \color{red}{R_x} \sin \theta &amp; \cos \theta + \color{blue}{R_z}^2(1 - \cos \theta) &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}<br>$$</p><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>当矩阵相乘时，在最右边的矩阵是第一个与向量相乘的，所以应该从右向左读矩阵乘法。</p><p>建议：<strong>在组合矩阵时，先进行缩放操作，然后是旋转，最后才是位移</strong></p><h2 id="GLM"><a href="#GLM" class="headerlink" title="GLM"></a>GLM</h2><p>GLM是在OpenGL中使用各类数学函数的头文件库。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glm/glm.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span><br></code></pre></td></tr></table></figure><p><code>glm::vec4 vec(x,y,z,w)</code>用于创建一个名为vec的四维向量。</p><p><code>glm::mat4 trans = glm::mat4(1.0f)</code>用于创建一个名为trans的四维矩阵，它是一个单位矩阵。</p><blockquote><p>直接使用glm::mat4创建矩阵，会生成一个零矩阵。</p></blockquote><p>当需要对一个向量进行变换操作时，用它乘以对应的变换矩阵即可。</p><h3 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h3><p><code>glm::translate(mat4, vec3)</code>用于创建一个位移变换矩阵。<code>mat4</code>一般就是单位矩阵，<code>vec3</code>是位移向量。</p><h3 id="缩放-1"><a href="#缩放-1" class="headerlink" title="缩放"></a>缩放</h3><p><code>glm::scale(mat4, vec3)</code>用于创建缩放变换矩阵。<code>mat4</code>是单位矩阵，<code>vec3</code>是各轴缩放系数。</p><h3 id="旋转-1"><a href="#旋转-1" class="headerlink" title="旋转"></a>旋转</h3><p><code>glm::rotate(mat4, radians, vec3)</code>用于创建旋转矩阵。<code>mat4</code>是单位矩阵，<code>radians</code>是需要旋转的弧度，<code>vec3</code>是旋转轴。</p><blockquote><p>radians是一个glm::radians类型变量，表示弧度。通过glm::radians(float angle)可把角度转换为弧度。</p></blockquote><h3 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h3><p>定义<code>mat4</code>类型的<code>uniform</code>，使用如下代码传递：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> transformLoc = <span class="hljs-built_in">glGetUniformLocation</span>(ourShader.ID, <span class="hljs-string">&quot;transform&quot;</span>);<br><span class="hljs-comment">//参数二：传递矩阵的个数</span><br><span class="hljs-comment">//参数三：是否转置。使用GLM（列主序）时无需转置</span><br><span class="hljs-comment">//参数四：把GLM矩阵转换为OpenGL可以读懂的类型</span><br><span class="hljs-built_in">glUniformMatrix4fv</span>(transformLoc, <span class="hljs-number">1</span>, GL_FALSE, glm::<span class="hljs-built_in">value_ptr</span>(trans));<br></code></pre></td></tr></table></figure><p>存在多个对象时，需要单独对每个对象进行变换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">shader.<span class="hljs-built_in">use</span>();<br>glm::mat4 trans = glm::<span class="hljs-built_in">mat4</span>(<span class="hljs-number">1.0f</span>);<br>trans = glm::<span class="hljs-built_in">translate</span>(trans,glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>));<br>trans = glm::<span class="hljs-built_in">scale</span>(trans,glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-built_in">sin</span>(<span class="hljs-built_in">glfwGetTime</span>()),<span class="hljs-built_in">sin</span>(<span class="hljs-built_in">glfwGetTime</span>()),<span class="hljs-number">0</span>));<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> transLoc = <span class="hljs-built_in">glGetUniformLocation</span>(shader.ID,<span class="hljs-string">&quot;trans&quot;</span>);<br><span class="hljs-built_in">glUniformMatrix4fv</span>(transLoc,<span class="hljs-number">1</span>,GL_FALSE,glm::<span class="hljs-built_in">value_ptr</span>(trans));<br><span class="hljs-built_in">glDrawElements</span>(GL_TRIANGLES,<span class="hljs-number">6</span>,GL_UNSIGNED_INT,<span class="hljs-number">0</span>);<br>trans = glm::<span class="hljs-built_in">mat4</span>(<span class="hljs-number">1.0f</span>);<br>trans = glm::<span class="hljs-built_in">translate</span>(trans,glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>));<br>trans = glm::<span class="hljs-built_in">rotate</span>(trans,<span class="hljs-number">100</span>*glm::<span class="hljs-built_in">radians</span>((<span class="hljs-type">float</span>)<span class="hljs-built_in">glfwGetTime</span>()),glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>));<br><span class="hljs-built_in">glUniformMatrix4fv</span>(transLoc,<span class="hljs-number">1</span>,GL_FALSE,glm::<span class="hljs-built_in">value_ptr</span>(trans));<br><span class="hljs-built_in">glDrawElements</span>(GL_TRIANGLES,<span class="hljs-number">6</span>,GL_UNSIGNED_INT,<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h1 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h1><p>通常情况下，顶点坐标不一定在NDC范围以内。我们需要在顶点着色器中自行把这些坐标转化为NDC坐标。</p><p>这个坐标转化的过程类似于流水线。</p><p>在坐标转换的过程中，有三个变换矩阵非常重要：</p><ul><li>模型（Model）矩阵</li><li>观察（View）矩阵</li><li>投影（Projection）矩阵</li></ul><p>坐标变换以下列顺序进行：</p><blockquote><p>局部坐标 -&gt; 世界坐标 -&gt; 观察坐标 -&gt; 裁剪坐标 -&gt; 屏幕坐标</p></blockquote><p><img src="https://learnopengl-cn.github.io/img/01/08/coordinate_systems.png" alt="coordinate_systems"></p><p>坐标变换概述：</p><ol><li>局部坐标是对象相对于局部原点的坐标，也是物体起始的坐标。</li><li>下一步是将局部坐标变换为世界空间坐标，世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其它物体一起相对于世界的原点进行摆放。</li><li>接下来我们将世界坐标变换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的。</li><li>坐标到达观察空间之后，我们需要将其投影到裁剪坐标。裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上。</li><li>最后，我们将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换(Viewport Transform)的过程。视口变换将位于-1.0到1.0范围的坐标变换到由glViewport函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段。</li></ol><h2 id="局部空间"><a href="#局部空间" class="headerlink" title="局部空间"></a>局部空间</h2><p>单个物体所在的坐标空间。只在单个物体上有意义。</p><h2 id="世界空间"><a href="#世界空间" class="headerlink" title="世界空间"></a>世界空间</h2><p>每个物体摆放的不同位置。</p><p>使用模型矩阵将局部左边转换为世界坐标。</p><h2 id="观察空间"><a href="#观察空间" class="headerlink" title="观察空间"></a>观察空间</h2><p>又称摄像机空间或视觉空间，是从摄像机的视角所观察到的空间。</p><p>使用观察矩阵，将世界坐标转换为观察坐标。</p><h2 id="裁剪空间"><a href="#裁剪空间" class="headerlink" title="裁剪空间"></a>裁剪空间</h2><p>对于任何屏幕上不可见的坐标，都应当被剔除。剔除完以后，剩下的坐标就是屏幕上可见的片段。</p><p>使用投影矩阵将观察坐标变换到裁剪坐标。投影矩阵指定了一个范围的坐标，比如在每个维度上的-1000到1000。投影矩阵接着会将在这个指定的范围内的坐标变换为标准化设备坐标的范围(-1.0, 1.0)。所有在范围外的坐标不会被映射到在-1.0到1.0的范围之间，所以会被裁剪掉。</p><blockquote><p>若一个图元一部分在裁剪范围内，一部分在范围外，在交界处将会生成新的顶点。</p></blockquote><p>投影矩阵创建了一个观察箱（Viewing Box），这个观察箱被称为平截头体（Frustum，Unity里称为<strong>视锥</strong>）。</p><p>投影（Projection）是把特定范围内的坐标转换到NDC范围内的过程。</p><p>所有顶点被变换到裁剪空间后，一次透视除法将会执行。具体表现为：位置向量的x，y，z分量分别除以齐次w分量。这一步骤由顶点着色器自动执行。</p><p>随后，最终坐标会被映射到屏幕空间中，并被变换为Fragment。</p><p>投影矩阵分为正交（Orthographic）和透视（Perspective）投影矩阵。</p><p>正交投影矩阵所框定的范围类似于一个长方体。变换后，每个向量的w分量都不会改变。</p><blockquote><p>使用<code>glm::ortho(left, right, bottom, top, near, far)</code>创建正射投影矩阵。</p><p>前两个参数为Frustum的左右坐标，第三、第四个参数为底部和顶部。第五第六个参数为近平面和远平面。</p></blockquote><p>投射投影矩阵所框定的范围类似于一个四边台体。它会修改每个顶点坐标的w值，使得离观察者越远的顶点坐标，w分量就越大。这样，在执行透视除法时，越远的顶点坐标，其x、y、z值会被除的越多，就好像被缩小了一样，从而达成“近大远小”的效果。</p><blockquote><p>使用<code>glm::mat4 proj = glm::perspective(glm::radians(angle), (float)width / (float)height, near, far)</code>创建投影矩阵。</p><p>参数一定义了视野（Field of view，FOV）的值，通常为45.0f.</p><p>参数二定义了宽高比。</p><p>参数三、四为近平面和远平面。</p></blockquote><h2 id="组合-1"><a href="#组合-1" class="headerlink" title="组合"></a>组合</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs math">V_&#123;clip&#125; = M_&#123;projection&#125; \cdot M_&#123;view&#125; \cdot M_&#123;model&#125; \cdot V_&#123;local&#125;<br><br></code></pre></td></tr></table></figure><p>经过上面的变换后，就能得到应当被赋给gl_Position的坐标。随后，Vertex Shader对其进行透视除法和裁剪。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>首先创建模型矩阵。一种直观理解模型矩阵的方式是，Unity中的Transform组件。</p><p><img src="https://img-blog.csdnimg.cn/2020112216001685.png#pic_center" alt="在这里插入图片描述"></p><p>模型矩阵对物体本身进行平移、旋转、缩放操作，对应Transform的三个属性。</p><p>要绘制世界坐标不同的物体的时候，只需要创建不同的模型矩阵即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">glm::mat4 model;<br><span class="hljs-comment">//该模型矩阵让物体绕x轴旋转-55°</span><br>model = glm::<span class="hljs-built_in">rotate</span>(model, glm::<span class="hljs-built_in">radians</span>(<span class="hljs-number">-55.0f</span>), glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>));<br></code></pre></td></tr></table></figure><p>随后创建观察矩阵。当没有观察矩阵时，摄像机处于世界空间原点。在使用上面那个模型矩阵变换的情况下，物体同样处在世界原点。所以我们要往后退，以看到物体。而往后退等价于让物体往后退，所以有观察矩阵：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">glm::mat4 view;<br><span class="hljs-comment">// 注意，我们将矩阵向我们要进行移动场景的反方向移动。</span><br><span class="hljs-comment">// OpenGL使用右手坐标系，z轴正方向指向屏幕外。</span><br>view = glm::<span class="hljs-built_in">translate</span>(view, glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">-3.0f</span>));<br></code></pre></td></tr></table></figure><p>最后创建投影矩阵。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">glm::mat4 projection;<br>projection = glm::<span class="hljs-built_in">perspective</span>(glm::<span class="hljs-built_in">radians</span>(<span class="hljs-number">45.0f</span>), screenWidth / screenHeight, <span class="hljs-number">0.1f</span>, <span class="hljs-number">100.0f</span>);<br></code></pre></td></tr></table></figure><p>然后修改Vertex Shader，并传入变换矩阵</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aCol;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> aTex;<br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> col;<br><span class="hljs-keyword">out</span> <span class="hljs-type">vec2</span> uv;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> model;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> view;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> proj;<br><br><span class="hljs-type">void</span> main()&#123;<br>    <span class="hljs-built_in">gl_Position</span> = proj*view*model*<span class="hljs-type">vec4</span>(aPos,<span class="hljs-number">1.0</span>);<br>    col = aCol;<br>    uv = aTex;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> modelLoc = <span class="hljs-built_in">glGetUniformLocation</span>(shader.ID,<span class="hljs-string">&quot;model&quot;</span>);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> viewLoc = <span class="hljs-built_in">glGetUniformLocation</span>(shader.ID,<span class="hljs-string">&quot;view&quot;</span>);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> projLoc = <span class="hljs-built_in">glGetUniformLocation</span>(shader.ID,<span class="hljs-string">&quot;proj&quot;</span>);<br><span class="hljs-built_in">glUniformMatrix4fv</span>(modelLoc,<span class="hljs-number">1</span>,GL_FALSE,glm::<span class="hljs-built_in">value_ptr</span>(model));<br><span class="hljs-built_in">glUniformMatrix4fv</span>(viewLoc,<span class="hljs-number">1</span>,GL_FALSE,glm::<span class="hljs-built_in">value_ptr</span>(view));<br><span class="hljs-built_in">glUniformMatrix4fv</span>(projLoc,<span class="hljs-number">1</span>,GL_FALSE,glm::<span class="hljs-built_in">value_ptr</span>(proj));<br><span class="hljs-built_in">glDrawElements</span>(GL_TRIANGLES,<span class="hljs-number">6</span>,GL_UNSIGNED_INT,<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="Z-Buffer"><a href="#Z-Buffer" class="headerlink" title="Z-Buffer"></a>Z-Buffer</h3><p>绘制立方体时，使用Z-Buffer解决覆盖问题。</p><p>GLFW自动生成Z-Buffer存储深度信息。片段想要输出它的颜色时，OpenGL会将它的深度值和z缓冲进行比较，如果当前的片段在其它片段之后，它将会被丢弃，否则将会覆盖。这个过程称为**深度测试(Depth Testing)**，它是由OpenGL自动完成的。</p><p>深度测试默认关闭，使用<code>glEnable(GL_DEPTH_TEST)</code>开启。</p><p>同时，深度缓冲也需要在每帧清除。</p><p><code>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</code></p><p>绘制许多物体时，不妨使用for循环+改变model矩阵的方式。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glad/glad.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;GLFW/glfw3.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;shader_s.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stb_image.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glm/glm.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">float</span> offsetX=<span class="hljs-number">0</span>;<br><span class="hljs-type">float</span> offsetY=<span class="hljs-number">0</span>;<br><span class="hljs-type">float</span> offsetZ=<span class="hljs-number">0</span>;<br><br>glm::vec3 cubePositions[] = &#123;<br>    glm::<span class="hljs-built_in">vec3</span>( <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.0f</span>),<br>    glm::<span class="hljs-built_in">vec3</span>( <span class="hljs-number">2.0f</span>,  <span class="hljs-number">5.0f</span>, <span class="hljs-number">-15.0f</span>),<br>    glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">-1.5f</span>, <span class="hljs-number">-2.2f</span>, <span class="hljs-number">-2.5f</span>),<br>    glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">-3.8f</span>, <span class="hljs-number">-2.0f</span>, <span class="hljs-number">-12.3f</span>),<br>    glm::<span class="hljs-built_in">vec3</span>( <span class="hljs-number">2.4f</span>, <span class="hljs-number">-0.4f</span>, <span class="hljs-number">-3.5f</span>),<br>    glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">-1.7f</span>,  <span class="hljs-number">3.0f</span>, <span class="hljs-number">-7.5f</span>),<br>    glm::<span class="hljs-built_in">vec3</span>( <span class="hljs-number">1.3f</span>, <span class="hljs-number">-2.0f</span>, <span class="hljs-number">-2.5f</span>),<br>    glm::<span class="hljs-built_in">vec3</span>( <span class="hljs-number">1.5f</span>,  <span class="hljs-number">2.0f</span>, <span class="hljs-number">-2.5f</span>),<br>    glm::<span class="hljs-built_in">vec3</span>( <span class="hljs-number">1.5f</span>,  <span class="hljs-number">0.2f</span>, <span class="hljs-number">-1.5f</span>),<br>    glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">-1.3f</span>,  <span class="hljs-number">1.0f</span>, <span class="hljs-number">-1.5f</span>)<br>  &#125;;<br><br><span class="hljs-type">float</span> vertices[] = &#123;<br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<br>     <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,<br>     <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>,<br>     <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>,<br>    <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,<br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<br><br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<br>     <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>,  <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,<br>     <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>,  <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>,<br>     <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>,  <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>,<br>    <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,<br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<br><br>    <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>,  <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,<br>    <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>,<br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,<br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,<br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<br>    <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>,  <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,<br><br>     <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>,  <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,<br>     <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>,<br>     <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,<br>     <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,<br>     <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<br>     <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>,  <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,<br><br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,<br>     <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>,<br>     <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>,  <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,<br>     <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>,  <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,<br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,<br><br>    <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,<br>     <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>,<br>     <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>,  <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,<br>     <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>,  <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,<br>    <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<br>    <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process_input</span><span class="hljs-params">(GLFWwindow* window)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">glfwGetKey</span>(window,GLFW_KEY_RIGHT)==GLFW_PRESS) &#123;<br>        offsetX+=<span class="hljs-number">0.01f</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">glfwGetKey</span>(window,GLFW_KEY_LEFT)==GLFW_PRESS) &#123;<br>        offsetX-=<span class="hljs-number">0.01f</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">glfwGetKey</span>(window,GLFW_KEY_UP)==GLFW_PRESS) &#123;<br>        offsetY+=<span class="hljs-number">0.01f</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">glfwGetKey</span>(window,GLFW_KEY_DOWN)==GLFW_PRESS) &#123;<br>        offsetY-=<span class="hljs-number">0.01f</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mouse_scroll_zoom</span><span class="hljs-params">(GLFWwindow* window, <span class="hljs-type">double</span> xoffset, <span class="hljs-type">double</span> yoffset)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(yoffset&gt;<span class="hljs-number">0</span>) &#123;<br>        offsetZ+=<span class="hljs-number">0.1f</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(yoffset&lt;<span class="hljs-number">0</span>) &#123;<br>        offsetZ-=<span class="hljs-number">0.1f</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">frame_buffer_size_callback</span><span class="hljs-params">(GLFWwindow* window, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> </span>&#123;<br>    <span class="hljs-built_in">glViewport</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,width,height);<br>&#125;<br><br><span class="hljs-function">GLFWwindow* <span class="hljs-title">sys_init</span><span class="hljs-params">(<span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> </span>&#123;<br>    <span class="hljs-comment">//glfw初始化</span><br>    <span class="hljs-built_in">glfwInit</span>();<br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR,<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR,<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE,GLFW_OPENGL_CORE_PROFILE);<br>    GLFWwindow* window = <span class="hljs-built_in">glfwCreateWindow</span>(<span class="hljs-number">800</span>,<span class="hljs-number">600</span>,<span class="hljs-string">&quot;LearnOpenGL&quot;</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(window==<span class="hljs-literal">NULL</span>) &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Failed to create window&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-built_in">glfwTerminate</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-built_in">glfwMakeContextCurrent</span>(window);<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress)) &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Failed to load proc&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-built_in">glfwTerminate</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-built_in">glViewport</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">800</span>,<span class="hljs-number">600</span>);<br>    <span class="hljs-built_in">glfwSetFramebufferSizeCallback</span>(window,frame_buffer_size_callback);<br>    <span class="hljs-built_in">glfwSetScrollCallback</span>(window,mouse_scroll_zoom);<br>    <span class="hljs-keyword">return</span> window;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_config_buffers</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> GLTYPE, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>* handle, <span class="hljs-type">void</span>* data, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size)</span> </span>&#123;<br>    <span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, handle);<br>    <span class="hljs-built_in">glBindBuffer</span>(GLTYPE, *handle);<br>    <span class="hljs-built_in">glBufferData</span>(GLTYPE, size, data, GL_STATIC_DRAW);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_config_vao</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *VAO, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *VBO, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *EBO)</span> </span>&#123;<br>    <span class="hljs-built_in">glGenVertexArrays</span>(<span class="hljs-number">1</span>, VAO);<br>    <span class="hljs-built_in">glBindVertexArray</span>(*VAO);<br><br>    <span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, *VBO);<br>    <span class="hljs-built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, *EBO);<br><br>    <span class="hljs-comment">// 激活顶点属性</span><br>    <span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">5</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">5</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)(<span class="hljs-number">3</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)));<br>    <span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-built_in">glBindVertexArray</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// Unbind VAO</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">quick_config_texture</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> IMAGETYPE)</span> </span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> texture;<br>    <span class="hljs-built_in">stbi_set_flip_vertically_on_load</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-built_in">glGenTextures</span>(<span class="hljs-number">1</span>,&amp;texture);<br>    <span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D,texture);<br>    <span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_REPEAT);<br>    <span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_REPEAT);<br>    <span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR);<br>    <span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);<br>    <span class="hljs-type">int</span> width,height,channels;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* data = <span class="hljs-built_in">stbi_load</span>(path, &amp;width, &amp;height,&amp;channels,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(data) &#123;<br>        <span class="hljs-built_in">glTexImage2D</span>(GL_TEXTURE_2D,<span class="hljs-number">0</span>,IMAGETYPE,width,height,<span class="hljs-number">0</span>,IMAGETYPE,GL_UNSIGNED_BYTE,data);<br>        <span class="hljs-built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Failed to load image&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">stbi_image_free</span>(data);<br>    <span class="hljs-keyword">return</span> texture;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//初始化系统与函数加载</span><br>    GLFWwindow* window = <span class="hljs-built_in">sys_init</span>(<span class="hljs-number">800</span>,<span class="hljs-number">600</span>);<br>    <span class="hljs-keyword">if</span>(window==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">//加载着色器</span><br>    <span class="hljs-function">Shader <span class="hljs-title">shader</span><span class="hljs-params">(<span class="hljs-string">&quot;Shaders/vertex.glsl&quot;</span>,<span class="hljs-string">&quot;Shaders/fragment.glsl&quot;</span>)</span></span>;<br>    <span class="hljs-comment">//配置VBO、EBO、VAO</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VBO, EBO, VAO;<br>    <span class="hljs-built_in">quick_config_buffers</span>(GL_ARRAY_BUFFER, &amp;VBO, vertices, <span class="hljs-built_in">sizeof</span>(vertices));<br>    <span class="hljs-built_in">quick_config_vao</span>(&amp;VAO, &amp;VBO, &amp;EBO);<br>    <span class="hljs-comment">//加载、配置纹理</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> textures[<span class="hljs-number">2</span>];<br>    textures[<span class="hljs-number">0</span>]=<span class="hljs-built_in">quick_config_texture</span>(<span class="hljs-string">&quot;Imgs/container.jpg&quot;</span>,GL_RGB);<br>    textures[<span class="hljs-number">1</span>]=<span class="hljs-built_in">quick_config_texture</span>(<span class="hljs-string">&quot;Imgs/awesomeface.png&quot;</span>,GL_RGBA);<br>    shader.<span class="hljs-built_in">use</span>();<br>    shader.<span class="hljs-built_in">setInt</span>(<span class="hljs-string">&quot;texture1&quot;</span>,<span class="hljs-number">0</span>);<br>    shader.<span class="hljs-built_in">setInt</span>(<span class="hljs-string">&quot;texture2&quot;</span>,<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">glActiveTexture</span>(GL_TEXTURE0);<br>    <span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D,textures[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">glActiveTexture</span>(GL_TEXTURE1);<br>    <span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D,textures[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">glEnable</span>(GL_DEPTH_TEST);<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">glfwWindowShouldClose</span>(window)) &#123;<br>        <span class="hljs-built_in">process_input</span>(window);<br>        <span class="hljs-built_in">glClearColor</span>(<span class="hljs-number">0.2f</span>,<span class="hljs-number">0.3f</span>,<span class="hljs-number">0.4f</span>,<span class="hljs-number">1.0f</span>);<br>        <span class="hljs-built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br>        shader.<span class="hljs-built_in">use</span>();<br>        <span class="hljs-comment">//变换</span><br>        glm::mat4 view = glm::<span class="hljs-built_in">mat4</span>(<span class="hljs-number">1.0f</span>);<br>        view = glm::<span class="hljs-built_in">translate</span>(view,glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>+offsetX,<span class="hljs-number">0.0f</span>+offsetY,<span class="hljs-number">-3.0f</span>+offsetZ));<br>        glm::mat4 proj = glm::<span class="hljs-built_in">perspective</span>(glm::<span class="hljs-built_in">radians</span>(<span class="hljs-number">45.0f</span>),<span class="hljs-number">800.0f</span>/<span class="hljs-number">600.0f</span>,<span class="hljs-number">0.1f</span>,<span class="hljs-number">100.0f</span>);<br>        shader.<span class="hljs-built_in">setMat4</span>(<span class="hljs-string">&quot;view&quot;</span>,view);<br>        shader.<span class="hljs-built_in">setMat4</span>(<span class="hljs-string">&quot;proj&quot;</span>,proj);<br>        <span class="hljs-built_in">glBindVertexArray</span>(VAO);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>        &#123;<br>            glm::mat4 model = glm::<span class="hljs-built_in">mat4</span>(<span class="hljs-number">1.0f</span>);<br>            model = glm::<span class="hljs-built_in">translate</span>(model, cubePositions[i]);<br>            <span class="hljs-type">float</span> angle = <span class="hljs-number">20.0f</span> * i;<br>            model = glm::<span class="hljs-built_in">rotate</span>(model, (<span class="hljs-type">float</span>)<span class="hljs-built_in">glfwGetTime</span>()*glm::<span class="hljs-built_in">radians</span>(angle), glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">0.5f</span>));<br>            shader.<span class="hljs-built_in">setMat4</span>(<span class="hljs-string">&quot;model&quot;</span>, model);<br>            <span class="hljs-built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">36</span>);<br>        &#125;<br>        <span class="hljs-comment">//收尾操作</span><br>        <span class="hljs-built_in">glfwSwapBuffers</span>(window);<br>        <span class="hljs-built_in">glfwPollEvents</span>();<br>    &#125;<br>    <span class="hljs-built_in">glDeleteTextures</span>(<span class="hljs-number">2</span>,textures);<br>    <span class="hljs-built_in">glfwTerminate</span>();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> aTex;<br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec2</span> uv;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> model;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> view;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> proj;<br><br><span class="hljs-type">void</span> main()&#123;<br>    <span class="hljs-built_in">gl_Position</span> = proj*view*model*<span class="hljs-type">vec4</span>(aPos,<span class="hljs-number">1.0</span>);<br>    uv = aTex;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> aTex;<br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec2</span> uv;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> model;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> view;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> proj;<br><br><span class="hljs-type">void</span> main()&#123;<br>    <span class="hljs-built_in">gl_Position</span> = proj*view*model*<span class="hljs-type">vec4</span>(aPos,<span class="hljs-number">1.0</span>);<br>    uv = aTex;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>图形学</tag>
      
      <tag>OpenGL</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LearnOpenGL学习笔记（二）</title>
    <link href="/2024/07/12/LearnOpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2024/07/12/LearnOpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>喘口气。<br>    <span id="more"></span></p><h1 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h1><h2 id="GLSL"><a href="#GLSL" class="headerlink" title="GLSL"></a>GLSL</h2><p>典型着色器程序的结构如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version version_number</span><br><span class="hljs-keyword">in</span> type in_variable_name;<br><span class="hljs-keyword">in</span> type in_variable_name;<br><span class="hljs-keyword">out</span> type out_variable_name;<br><span class="hljs-keyword">uniform</span> type uniform_name;<br><span class="hljs-type">int</span> main()<br>&#123;<br>  <span class="hljs-comment">// 处理输入并进行一些图形操作</span><br>  ...<br>  <span class="hljs-comment">// 输出处理过的结果到输出变量</span><br>  out_variable_name = weird_stuff_we_processed;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>对于Vertex Shader，输入变量被称为Vertex Attribute。在OpenGL中一般至少能声明16个Vertex Attribute，每个含4个分量。</p></blockquote><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p>向量是GLSL中最常用的数据类型。包含<code>vecn</code>、<code>bvecn</code>、<code>ivecn</code>、<code>uvecn</code>、<code>dvecn</code>。前缀代表分量的基本类型，后缀n代表维度数。一般使用<code>vecn</code>。</p><p>使用<code>.x</code>、<code>.y</code>、<code>.z</code>和<code>.w</code>来获取它们的第1、2、3、4个分量。GLSL也允许对颜色使用<code>rgba</code>，或是对纹理坐标使用<code>stpq</code>访问相同的分量。</p><p>与CG类似，可以通过重组（Swizzling）的方式填充向量分量。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">vec2</span> someVec;<br><span class="hljs-type">vec4</span> differentVec = someVec.xyxx;<br><span class="hljs-type">vec3</span> anotherVec = differentVec.zyw;<br><span class="hljs-type">vec4</span> otherVec = someVec.xxxx + anotherVec.yxzy;<br></code></pre></td></tr></table></figure><p>与此同时，还可以使用向量构造函数直接给向量变量复制，如<code>vec2 vect = vec2(0.5, 0.7)</code></p><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p><code>in</code>和<code>out</code>关键字用于定义着色器的输入和输出。只要一个输出变量与下一个着色器阶段的输入匹配，它就会传递下去（前一阶段的输出变量的变量名，应当与后阶段的输入变量的变量名相同）。但在顶点和片段着色器中会有点不同。</p><p>对于Vertex Shader，其特殊点在于<code>location</code>关键字。<code>location</code>定义了着色器从顶点数据的哪一部分接收数据。例如，在Vertex Shader中，我定义了两个<code>vec4</code>，第一个是位置数据aPos，它的<code>location</code>是0；第二个是颜色数据<code>aCol</code>，它的<code>location</code>是1。</p><p>使用<code>layout (location = 0)</code>定义某输入变量的<code>location</code>。</p><p>对于Fragment Shader，应当始终保证存在一个<code>vec4</code>型输出变量，用于输出最终颜色。</p><h3 id="Uniform"><a href="#Uniform" class="headerlink" title="Uniform"></a>Uniform</h3><p><code>Uniform</code>用于在cpp程序中向着色器输入数据，改变其表现。</p><p>如其名，<code>Uniform</code>在每个着色器程序中都是独一无二的。在这个Program链接的所有Shader中，只能存在一个相同名称的<code>Uniform</code>。</p><p>使用<code>uniform</code>关键字定义<code>Uniform</code>变量。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec4</span> ourColor;<br></code></pre></td></tr></table></figure><p>在cpp程序中改变<code>uniform</code>的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> timeValue = <span class="hljs-built_in">glfwGetTime</span>(); <span class="hljs-comment">//获取当前程序运行的秒数</span><br><span class="hljs-type">float</span> greenValue = (<span class="hljs-built_in">sin</span>(timeValue) / <span class="hljs-number">2.0f</span>) + <span class="hljs-number">0.5f</span>;<br><span class="hljs-comment">//使用glGetUniformLocation函数，在shaderProgram程序中获取名为&quot;outColor&quot;的Uniform变量位置</span><br><span class="hljs-type">int</span> vertexColorLocation = <span class="hljs-built_in">glGetUniformLocation</span>(shaderProgram, <span class="hljs-string">&quot;ourColor&quot;</span>);<br><span class="hljs-built_in">glUseProgram</span>(shaderProgram);<br><span class="hljs-comment">//获取位置后，使用glUniform4f函数，以之前获取的位置为参数，设置它的值。</span><br><span class="hljs-built_in">glUniform4f</span>(vertexColorLocation, <span class="hljs-number">0.0f</span>, greenValue, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);<br></code></pre></td></tr></table></figure><blockquote><p>更新uniform值时，必须Use它所在的Program，否则更新无效。</p><p>除glUniform4f外，还有glUniform3i（ivec3)、glUniformfv（float[]或vecn）、glUniformui(unsigned int)等。</p></blockquote><h2 id="多顶点属性"><a href="#多顶点属性" class="headerlink" title="多顶点属性"></a>多顶点属性</h2><p>考虑如下顶点数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> vertices[] = &#123;<br>    <span class="hljs-comment">// 位置              // 颜色</span><br>     <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// 右下</span><br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// 左下</span><br>     <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>    <span class="hljs-comment">// 顶部</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>我们知道，可以使用<code>layout(location = x)</code>来标记不同的顶点属性，通过<code>gVertexAttribPointer</code>来告诉程序该如何处理这些不同的属性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 位置属性</span><br><span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">6</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<br><span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">0</span>);<br><span class="hljs-comment">// 颜色属性</span><br><span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">6</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)(<span class="hljs-number">3</span>* <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)));<br><span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h3 id="自定义着色器类"><a href="#自定义着色器类" class="headerlink" title="自定义着色器类"></a>自定义着色器类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SHADER_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SHADER_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glad/glad.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shader</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ID;<br>    <span class="hljs-comment">// constructor generates the shader on the fly</span><br>    <span class="hljs-comment">// ------------------------------------------------------------------------</span><br>    <span class="hljs-built_in">Shader</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* vertexPath, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* fragmentPath)<br>    &#123;<br>        <span class="hljs-comment">// 1. retrieve the vertex/fragment source code from filePath</span><br>        std::string vertexCode;<br>        std::string fragmentCode;<br>        std::ifstream vShaderFile;<br>        std::ifstream fShaderFile;<br>        <span class="hljs-comment">// ensure ifstream objects can throw exceptions:</span><br>        vShaderFile.<span class="hljs-built_in">exceptions</span> (std::ifstream::failbit | std::ifstream::badbit);<br>        fShaderFile.<span class="hljs-built_in">exceptions</span> (std::ifstream::failbit | std::ifstream::badbit);<br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            <span class="hljs-comment">// open files</span><br>            vShaderFile.<span class="hljs-built_in">open</span>(vertexPath);<br>            fShaderFile.<span class="hljs-built_in">open</span>(fragmentPath);<br>            std::stringstream vShaderStream, fShaderStream;<br>            <span class="hljs-comment">// read file&#x27;s buffer contents into streams</span><br>            vShaderStream &lt;&lt; vShaderFile.<span class="hljs-built_in">rdbuf</span>();<br>            fShaderStream &lt;&lt; fShaderFile.<span class="hljs-built_in">rdbuf</span>();<br>            <span class="hljs-comment">// close file handlers</span><br>            vShaderFile.<span class="hljs-built_in">close</span>();<br>            fShaderFile.<span class="hljs-built_in">close</span>();<br>            <span class="hljs-comment">// convert stream into string</span><br>            vertexCode   = vShaderStream.<span class="hljs-built_in">str</span>();<br>            fragmentCode = fShaderStream.<span class="hljs-built_in">str</span>();<br>        &#125;<br>        <span class="hljs-built_in">catch</span> (std::ifstream::failure&amp; e)<br>        &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;ERROR::SHADER::FILE_NOT_SUCCESSFULLY_READ: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* vShaderCode = vertexCode.<span class="hljs-built_in">c_str</span>();<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> * fShaderCode = fragmentCode.<span class="hljs-built_in">c_str</span>();<br>        <span class="hljs-comment">// 2. compile shaders</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> vertex, fragment;<br>        <span class="hljs-comment">// vertex shader</span><br>        vertex = <span class="hljs-built_in">glCreateShader</span>(GL_VERTEX_SHADER);<br>        <span class="hljs-built_in">glShaderSource</span>(vertex, <span class="hljs-number">1</span>, &amp;vShaderCode, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">glCompileShader</span>(vertex);<br>        <span class="hljs-built_in">checkCompileErrors</span>(vertex, <span class="hljs-string">&quot;VERTEX&quot;</span>);<br>        <span class="hljs-comment">// fragment Shader</span><br>        fragment = <span class="hljs-built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);<br>        <span class="hljs-built_in">glShaderSource</span>(fragment, <span class="hljs-number">1</span>, &amp;fShaderCode, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">glCompileShader</span>(fragment);<br>        <span class="hljs-built_in">checkCompileErrors</span>(fragment, <span class="hljs-string">&quot;FRAGMENT&quot;</span>);<br>        <span class="hljs-comment">// shader Program</span><br>        ID = <span class="hljs-built_in">glCreateProgram</span>();<br>        <span class="hljs-built_in">glAttachShader</span>(ID, vertex);<br>        <span class="hljs-built_in">glAttachShader</span>(ID, fragment);<br>        <span class="hljs-built_in">glLinkProgram</span>(ID);<br>        <span class="hljs-built_in">checkCompileErrors</span>(ID, <span class="hljs-string">&quot;PROGRAM&quot;</span>);<br>        <span class="hljs-comment">// delete the shaders as they&#x27;re linked into our program now and no longer necessary</span><br>        <span class="hljs-built_in">glDeleteShader</span>(vertex);<br>        <span class="hljs-built_in">glDeleteShader</span>(fragment);<br>    &#125;<br>    <span class="hljs-comment">// activate the shader</span><br>    <span class="hljs-comment">// ------------------------------------------------------------------------</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">glUseProgram</span>(ID);<br>    &#125;<br>    <span class="hljs-comment">// utility uniform functions</span><br>    <span class="hljs-comment">// ------------------------------------------------------------------------</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setBool</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;name, <span class="hljs-type">bool</span> value)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">glUniform1i</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), (<span class="hljs-type">int</span>)value);<br>    &#125;<br>    <span class="hljs-comment">// ------------------------------------------------------------------------</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setInt</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;name, <span class="hljs-type">int</span> value)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">glUniform1i</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), value);<br>    &#125;<br>    <span class="hljs-comment">// ------------------------------------------------------------------------</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setFloat</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;name, <span class="hljs-type">float</span> value)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">glUniform1f</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), value);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// utility function for checking shader compilation/linking errors.</span><br>    <span class="hljs-comment">// ------------------------------------------------------------------------</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">checkCompileErrors</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> shader, std::string type)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> success;<br>        <span class="hljs-type">char</span> infoLog[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">if</span> (type != <span class="hljs-string">&quot;PROGRAM&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">glGetShaderiv</span>(shader, GL_COMPILE_STATUS, &amp;success);<br>            <span class="hljs-keyword">if</span> (!success)<br>            &#123;<br>                <span class="hljs-built_in">glGetShaderInfoLog</span>(shader, <span class="hljs-number">1024</span>, <span class="hljs-literal">NULL</span>, infoLog);<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;ERROR::SHADER_COMPILATION_ERROR of type: &quot;</span> &lt;&lt; type &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="hljs-string">&quot;\n -- --------------------------------------------------- -- &quot;</span> &lt;&lt; std::endl;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">glGetProgramiv</span>(shader, GL_LINK_STATUS, &amp;success);<br>            <span class="hljs-keyword">if</span> (!success)<br>            &#123;<br>                <span class="hljs-built_in">glGetProgramInfoLog</span>(shader, <span class="hljs-number">1024</span>, <span class="hljs-literal">NULL</span>, infoLog);<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;ERROR::PROGRAM_LINKING_ERROR of type: &quot;</span> &lt;&lt; type &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="hljs-string">&quot;\n -- --------------------------------------------------- -- &quot;</span> &lt;&lt; std::endl;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><blockquote><p>Shader对象的构造必须要在加载完GLAD proc以后，否则报错。</p></blockquote><h1 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>纹理（Texture）用于在不增加顶点数量的情况下添加物体的细节。它就像一层贴纸一样贴在几何体上。</p><blockquote><p>纹理也可以用来存储数据。</p></blockquote><p>纹理“贴”到几何体上的过程被称为映射（Map）。纹理坐标（Texture Coordinate）用于指定某个顶点该从纹理的哪个位置采样（Sample，采集Fragment颜色）。非顶点的几何体区域通过片段插值（Fragment Interpolation）采样。</p><p>纹理坐标以左下角为原点，右上角为（1, 1）点。</p><p>对于超出[0, 1]范围的纹理坐标，可以指定纹理环绕方式来处理。</p><table><thead><tr><th align="left">环绕方式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">GL_REPEAT</td><td align="left">对纹理的默认行为。重复纹理图像。(用于二方连续纹理)</td></tr><tr><td align="left">GL_MIRRORED_REPEAT</td><td align="left">和GL_REPEAT一样，但每次重复图片是镜像放置的。</td></tr><tr><td align="left">GL_CLAMP_TO_EDGE</td><td align="left">纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。（Unity中默认模式）</td></tr><tr><td align="left">GL_CLAMP_TO_BORDER</td><td align="left">超出的坐标为用户指定的边缘颜色。</td></tr></tbody></table><p><img src="https://learnopengl-cn.github.io/img/01/06/texture_wrapping.png" alt="img"></p><p>使用<code>glTexParameterx</code>函数对特定坐标轴设置环绕方式。其中的‘x’代表数据类型，如i（int）、fv（float[]）等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//参数一指定纹理目标</span><br><span class="hljs-comment">//参数二指定参数选项以及坐标轴。S轴（x轴）T轴（y轴）</span><br><span class="hljs-comment">//参数三指定环绕方式</span><br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);<br></code></pre></td></tr></table></figure><p>选择GL_CLAMP_TO_BORDER时，使用float数组传入颜色数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> borderColor[] = &#123; <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span> &#125;;<br><span class="hljs-built_in">glTexParameterfv</span>(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);<br></code></pre></td></tr></table></figure><h2 id="纹理过滤"><a href="#纹理过滤" class="headerlink" title="纹理过滤"></a>纹理过滤</h2><p>纹理坐标可以是任意精度的浮点值，但纹理本身的分辨率却是有限的。因此，OpenGL需要知道，当指定一个纹理坐标时，该如何采样这个点上的像素。最为常见的是<code>GL_NEAREST</code>和<code>GL_LINEAR</code>。前者选择最接近坐标的哪个像素，后者会基于坐标附近的像素，计算出插值。像素中心离坐标越近，它对最终颜色的贡献就越大。</p><p>二者的主要区别在于，前者会显得更“锯齿”，后者会显得更“模糊”。</p><p>当缩放几何体的时候，常常需要对纹理过滤进行设置，通常的做法是在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。因为纹理缩小时，纹理像素也会变小，在视觉上，它的“分辨率似乎提高了”。因此，此时采用NEAREST过滤，纹理看起来就不会那么“锯齿化”。纹理放大时，像素看起来会更”明显“，所以使用LINEAR方法让纹理像素不那么明显，过渡更加平滑。</p><p>使用<code>glTexParameterx</code>函数为放大和缩小操作指定过滤方式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);<br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br></code></pre></td></tr></table></figure><h2 id="多级渐远纹理"><a href="#多级渐远纹理" class="headerlink" title="多级渐远纹理"></a>多级渐远纹理</h2><p>在我们当前的理解中，无论物体远近，其被映射的纹理的分辨率是不变的。对于非常远的物体，它们只会产生很少的Fragment。而OpenGL需要在如此高分辨率的纹理上拾取区区几个像素，是非常困难，并且效果不好的。为了解决这一问题，OpenGL引入了多级渐远纹理（Mipmap）。</p><p><img src="https://learnopengl-cn.github.io/img/01/06/mipmaps.png" alt="img"></p><p>Mipmap中，每个纹理的大小是前一个纹理的二分之一。当物体与相机的距离超过一定阈值后，OpenGL会采用小一级的纹理进行采样。</p><p>通过<code>glGenerateMipmap</code>函数创建Mipmap。</p><p>与纹理过滤选项类似，OpenGL提供了多种Mipmap匹配选项，用于缓解阈值附近Mipmap切换突兀的问题。</p><table><thead><tr><th align="left">过滤方式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">GL_NEAREST_MIPMAP_NEAREST</td><td align="left">使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样</td></tr><tr><td align="left">GL_LINEAR_MIPMAP_NEAREST</td><td align="left">使用最邻近的多级渐远纹理级别，并使用线性插值进行采样</td></tr><tr><td align="left">GL_NEAREST_MIPMAP_LINEAR</td><td align="left">在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样</td></tr><tr><td align="left">GL_LINEAR_MIPMAP_LINEAR</td><td align="left">在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样</td></tr></tbody></table><p>使用<code>glTexParameteri</code>设置Mipmap过滤方式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);<br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br></code></pre></td></tr></table></figure><p>一般只会对MIN_FILTER选项使用Mipmap。对MAG_FILTER使用Mipmap是不正确的。</p><h2 id="加载与创建"><a href="#加载与创建" class="headerlink" title="加载与创建"></a>加载与创建</h2><p>头文件<code>stb_image.h</code>中的<code>stbi_load</code>函数接收图片路径作为输入，将图片的宽度、高度和颜色通道数输出到三个int变量上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> width, height, nrChannels;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *data = <span class="hljs-built_in">stbi_load</span>(<span class="hljs-string">&quot;container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>与<code>glGenBuffers</code>类似，使用<code>glGenTextures(int cnt, unsigned int* addr)</code>生成纹理对象并获取句柄。</p><p>使用<code>glBindTexture(GL_TEXTURE_2D, unsigned int texture)</code>绑定纹理对象句柄与上下文目标。</p><p>使用<code>glTexImage2d</code>将图片信息复制到上下文目标中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//上下文目标 | Mipmap级别 | 纹理存储格式 | 图片宽度 | 图片高度 | 总是为0 | 原图的格式 | 原图的数据类型 | 图像数据</span><br><span class="hljs-built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_RGB, width, height, <span class="hljs-number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);<br><span class="hljs-built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);<br></code></pre></td></tr></table></figure><p>与<code>glBufferData</code>类似，<code>glTexImage2d</code>的作用就是让当前绑定的纹理对象附加上真正的纹理图像。</p><p><code>glGenerateMipmap(GL_TEXTURE_2D)</code>让OpenGL自动为我们生成、配置Mipmap，无需手动配置。</p><p>完成纹理和Mipmap生成后，应当释放图片内存：<code>stbi_image_free(data);</code></p><p>完整的生成纹理过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> texture;<br><span class="hljs-built_in">glGenTextures</span>(<span class="hljs-number">1</span>, &amp;texture);<br><span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);<br><span class="hljs-comment">// 为当前绑定的纹理对象设置环绕、过滤方式</span><br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   <br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);<br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);<br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br><span class="hljs-comment">// 加载并生成纹理</span><br><span class="hljs-type">int</span> width, height, nrChannels;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *data = <span class="hljs-built_in">stbi_load</span>(<span class="hljs-string">&quot;container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (data)<br>&#123;<br>    <span class="hljs-built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_RGB, width, height, <span class="hljs-number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);<br>    <span class="hljs-built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Failed to load texture&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-built_in">stbi_image_free</span>(data);<br></code></pre></td></tr></table></figure><h2 id="纹理单元"><a href="#纹理单元" class="headerlink" title="纹理单元"></a>纹理单元</h2><p><code>sample2d</code>类型uniform无需使用<code>glUniform</code>赋值。但<code>glUniform</code>可以设置<code>sampler2d</code>的位置值，这样我们就能给着色器设置多个纹理。一个纹理的位置值称为一个纹理单元（Texture Unit），其默认值为0。</p><p>使用<code>glActiveTexture(GL_TEXTUREX)</code>激活X号纹理单元， 随后使用<code>glBindTexture</code>为该位置值的纹理单元绑定纹理对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">glActiveTexture</span>(GL_TEXTURE0);<br><span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, texture1);<br><span class="hljs-built_in">glActiveTexture</span>(GL_TEXTURE1);<br><span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, texture2);<br></code></pre></td></tr></table></figure><p>使用自定义着色器类的<code>setInt</code>函数设置纹理单元位置值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ourShader.<span class="hljs-built_in">setInt</span>(<span class="hljs-string">&quot;texture2&quot;</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>在OpenGL中，纹理坐标的原点在左下角。而多数图像文件格式如PNG、JPEG等原点在左上角。所以直接加载这类图片会导致图片上下颠倒。</p><p>使用<code>stbi_set_flip_vertically_on_load(true)</code>反转图片y轴。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glad/glad.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;GLFW/glfw3.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;valarray&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;shader_s.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stb_image.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">float</span> vertices[] = &#123;<br>    <span class="hljs-comment">//     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -</span><br>    <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>,   <span class="hljs-comment">// 右上</span><br>    <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// 右下</span><br>   <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,   <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// 左下</span><br>   <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>    <span class="hljs-comment">// 左上</span><br>&#125;;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> indices[] = &#123;<br>    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">frame_buffer_size_callback</span><span class="hljs-params">(GLFWwindow* window, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> </span>&#123;<br>    <span class="hljs-built_in">glViewport</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// glfw初始化</span><br>    <span class="hljs-built_in">glfwInit</span>();<br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);<br>    GLFWwindow* window = <span class="hljs-built_in">glfwCreateWindow</span>(<span class="hljs-number">800</span>, <span class="hljs-number">600</span>, <span class="hljs-string">&quot;LearnOpenGL&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (window == <span class="hljs-literal">NULL</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Failed to create window&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">glfwTerminate</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">glfwMakeContextCurrent</span>(window);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Failed to load proc&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">glfwTerminate</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">glViewport</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">800</span>, <span class="hljs-number">600</span>);<br>    <span class="hljs-built_in">glfwSetFramebufferSizeCallback</span>(window, frame_buffer_size_callback);<br>    <span class="hljs-function">Shader <span class="hljs-title">shader</span><span class="hljs-params">(<span class="hljs-string">&quot;C:\\Users\\msik\\CLionProjects\\LearnOpenGL\\Shaders\\vertex.glsl&quot;</span>, <span class="hljs-string">&quot;C:\\Users\\msik\\CLionProjects\\LearnOpenGL\\Shaders\\fragment.glsl&quot;</span>)</span></span>;<br><br>    <span class="hljs-comment">// 加载纹理</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* data[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> width[<span class="hljs-number">2</span>], height[<span class="hljs-number">2</span>], channels[<span class="hljs-number">2</span>];<br>    <span class="hljs-built_in">stbi_set_flip_vertically_on_load</span>(<span class="hljs-literal">true</span>);<br>    data[<span class="hljs-number">0</span>] = <span class="hljs-built_in">stbi_load</span>(<span class="hljs-string">&quot;C:\\Users\\msik\\CLionProjects\\LearnOpenGL\\container.jpg&quot;</span>, &amp;width[<span class="hljs-number">0</span>], &amp;height[<span class="hljs-number">0</span>], &amp;channels[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>);<br>    data[<span class="hljs-number">1</span>] = <span class="hljs-built_in">stbi_load</span>(<span class="hljs-string">&quot;C:\\Users\\msik\\CLionProjects\\LearnOpenGL\\awesomeface.png&quot;</span>, &amp;width[<span class="hljs-number">1</span>], &amp;height[<span class="hljs-number">1</span>], &amp;channels[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> textures[<span class="hljs-number">2</span>];<br>    <span class="hljs-built_in">glGenTextures</span>(<span class="hljs-number">2</span>, textures);<br><br>    <span class="hljs-comment">// 纹理1</span><br>    <span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, textures[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);<br>    <span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);<br>    <span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);<br>    <span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br>    <span class="hljs-keyword">if</span> (data[<span class="hljs-number">0</span>]) &#123;<br>        <span class="hljs-built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_RGB, width[<span class="hljs-number">0</span>], height[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Failed to load texture 1&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 纹理2</span><br>    <span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, textures[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);<br>    <span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);<br>    <span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);<br>    <span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br>    <span class="hljs-keyword">if</span> (data[<span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_RGBA, width[<span class="hljs-number">1</span>], height[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, data[<span class="hljs-number">1</span>]);<br>        <span class="hljs-built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Failed to load texture 2&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 释放图像数据</span><br>    <span class="hljs-built_in">stbi_image_free</span>(data[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">stbi_image_free</span>(data[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-comment">// VAO</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VAO;<br>    <span class="hljs-built_in">glGenVertexArrays</span>(<span class="hljs-number">1</span>, &amp;VAO);<br>    <span class="hljs-built_in">glBindVertexArray</span>(VAO);<br><br>    <span class="hljs-comment">// VBO</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VBO;<br>    <span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;VBO);<br>    <span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);<br>    <span class="hljs-built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<br><br>    <span class="hljs-comment">// EBO</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> EBO;<br>    <span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;EBO);<br>    <span class="hljs-built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);<br>    <span class="hljs-built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);<br><br>    <span class="hljs-comment">// 顶点属性PTR</span><br>    <span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">8</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">8</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)(<span class="hljs-number">3</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)));<br>    <span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">8</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)(<span class="hljs-number">6</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)));<br>    <span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">2</span>);<br><br>    shader.<span class="hljs-built_in">use</span>();<br>    shader.<span class="hljs-built_in">setInt</span>(<span class="hljs-string">&quot;texture1&quot;</span>, <span class="hljs-number">0</span>);<br>    shader.<span class="hljs-built_in">setInt</span>(<span class="hljs-string">&quot;texture2&quot;</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">glfwWindowShouldClose</span>(window)) &#123;<br>        <span class="hljs-built_in">glClearColor</span>(<span class="hljs-number">0.2f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">0.4f</span>, <span class="hljs-number">1.0f</span>);<br>        <span class="hljs-built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<br><br>        <span class="hljs-comment">// 绑定纹理</span><br>        <span class="hljs-built_in">glActiveTexture</span>(GL_TEXTURE0);<br>        <span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, textures[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">glActiveTexture</span>(GL_TEXTURE1);<br>        <span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, textures[<span class="hljs-number">1</span>]);<br><br>        shader.<span class="hljs-built_in">use</span>();<br>        <span class="hljs-built_in">glBindVertexArray</span>(VAO);<br>        <span class="hljs-built_in">glDrawElements</span>(GL_TRIANGLES, <span class="hljs-number">6</span>, GL_UNSIGNED_INT, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-built_in">glfwSwapBuffers</span>(window);<br>        <span class="hljs-built_in">glfwPollEvents</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">glfwTerminate</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> col;<br><span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> uv;<br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> fragcolor;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> texture1;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> texture2;<br><br><span class="hljs-type">void</span> main()&#123;<br>    fragcolor = <span class="hljs-built_in">mix</span>(<span class="hljs-built_in">texture</span>(texture1,uv),<span class="hljs-built_in">texture</span>(texture2,uv),<span class="hljs-number">0.2</span>f);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aCol;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> aTex;<br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> col;<br><span class="hljs-keyword">out</span> <span class="hljs-type">vec2</span> uv;<br><br><span class="hljs-type">void</span> main()&#123;<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(aPos,<span class="hljs-number">1.0</span>);<br>    col = aCol;<br>    uv = aTex;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>图形学</tag>
      
      <tag>OpenGL</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LearnOpenGL学习笔记（一）</title>
    <link href="/2024/07/10/LearnOpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2024/07/10/LearnOpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>为终身之路踏上第一步。<br>    <span id="more"></span></p><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>OpenGL可以被看作是一个大的状态机。API中的一些函数会根据当前OpenGL的状态的不同，而产生不同的效果，这些函数被称为状态函数。</p><blockquote><p>OpenGL的工作流：</p><p>创建对象-&gt;绑定对象到上下文（Bind Gen出来的Object到OpenGL上下文的内置属性）-&gt;设置已绑定对象的选项-&gt;解绑对象</p><p>PS：解绑对象只是让对象和上下文之间断开联系。实际上选项已经改变，与解绑无关。当要获取之前那个对象的信息时，只需要重新绑定那个上下文变量就行了。比如说我们有一些作为3D模型数据（一栋房子或一个人物）的容器对象，在我们想绘制其中任何一个模型的时候，只需绑定一个包含对应模型数据的对象就可以了。拥有数个这样的对象允许我们指定多个模型，在想画其中任何一个的时候，直接将对应的对象绑定上去，便不需要再重复设置选项了。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">// 创建对象</span><br>unsigned <span class="hljs-type">int</span> objectId = <span class="hljs-number">0</span>;<br>glGenObject(<span class="hljs-number">1</span>, &amp;objectId);<br><span class="hljs-comment">// 绑定对象至上下文</span><br>glBindObject(GL_WINDOW_TARGET, objectId);<br><span class="hljs-comment">// 设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项</span><br>glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, <span class="hljs-number">800</span>);<br>glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, <span class="hljs-number">600</span>);<br><span class="hljs-comment">// 将上下文对象设回默认</span><br>glBindObject(GL_WINDOW_TARGET, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></blockquote><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="GLFW"><a href="#GLFW" class="headerlink" title="GLFW"></a>GLFW</h3><p>下载源代码，使用Clion打开源代码根目录作为项目。</p><p>点击构建-构建项目，完成后在cmake-build-output&#x2F;src文件夹下找到glfw3.dll文件。</p><p>新建空项目，新建libs和include文件夹，将GLFW源代码中include文件夹的内容拖入新include文件夹，将编译完成的glfw3.dll拖入libs文件夹。<strong>同时，也要把glfw3.dll拖入cmake-build-output文件夹下</strong></p><p>修改CMakeList.txt内容如下:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.28</span>)<br><span class="hljs-keyword">project</span>(LearnOpenGL) <span class="hljs-comment"># 定义项目名</span><br><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><br><span class="hljs-keyword">add_executable</span>(LearnOpenGL main.cpp) <span class="hljs-comment"># 这步必须放在链接操作之前</span><br><br><span class="hljs-keyword">INCLUDE_DIRECTORIES</span>(<span class="hljs-keyword">include</span>) <span class="hljs-comment"># include文件所在路径</span><br><span class="hljs-keyword">link_directories</span>(libs) <span class="hljs-comment"># libs文件所在路径</span><br><span class="hljs-keyword">target_link_libraries</span>(LearnOpenGL libs/glfw3.dll) <span class="hljs-comment"># dll文件所在路径</span><br></code></pre></td></tr></table></figure><p>重新加载CMake即可。可新建cpp文件，输入<code>#include &lt;GLFW\glfw3.h&gt;</code>，若未报错则链接成功。</p><h3 id="GLAD"><a href="#GLAD" class="headerlink" title="GLAD"></a>GLAD</h3><p>打开<a href="http://glad.dav1d.de/%EF%BC%8C%E6%8C%89%E7%85%A7%E4%BB%A5%E4%B8%8B%E8%A7%84%E5%88%99%E9%85%8D%E7%BD%AE%EF%BC%9A">http://glad.dav1d.de/，按照以下规则配置：</a></p><p>Language：C&#x2F;C++</p><p>Specification：OpenGL</p><p>API-gl：3.3 and newer</p><p>Opentions - Generate a loader：打勾</p><p>点击Generate按钮，下载glad.zip，解压，将include内的文件拖动到工程的include文件里，glad.c则放到工程根目录。使用<code>#include &lt;glad\glad.h&gt;</code>验证是否配置成功。</p><h2 id="范例工程"><a href="#范例工程" class="headerlink" title="范例工程"></a>范例工程</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glad/glad.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;GLFW/glfw3.h&gt;</span></span><br></code></pre></td></tr></table></figure><p>注意：<strong>glad头文件必须在GLFW之前include</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glad/glad.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;GLFW/glfw3.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//处理键盘输入，当用户按下ESC键时，提醒程序要退出</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processInput</span><span class="hljs-params">(GLFWwindow *window)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//glfwGetKey函数用于检查一个键是否正在被按下</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)<br>        <span class="hljs-built_in">glfwSetWindowShouldClose</span>(window, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-comment">//回调函数，使视口范围随窗口大小变化。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">framebuffer_size_callback</span><span class="hljs-params">(GLFWwindow* window, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">glViewport</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// -----------glfw初始化与窗口创建-----------</span><br>    <span class="hljs-comment">// 初始化glfw组件</span><br>    <span class="hljs-built_in">glfwInit</span>();<br>    <span class="hljs-comment">//指定opengl版本为3.3</span><br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="hljs-number">3</span>);<br>    <span class="hljs-comment">//告诉glfw我们使用的是核心模式</span><br>    <span class="hljs-comment">//核心模式意味着我们只能使用OpenGL功能的核心功能子集</span><br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE,GLFW_OPENGL_CORE_PROFILE);<br>    <span class="hljs-comment">//创建glfw窗口</span><br>    <span class="hljs-comment">//第一个参数是窗口的宽度，第二个是高度，第三个是窗口的标题，第四个参数指定窗口是否共享资源，第五个参数是共享资源的窗口</span><br>    <span class="hljs-comment">//共享资源指的是多个窗口可以共享同一个上下文</span><br>    GLFWwindow* window = <span class="hljs-built_in">glfwCreateWindow</span>(<span class="hljs-number">800</span>, <span class="hljs-number">600</span>, <span class="hljs-string">&quot;LearnOpenGL&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">//检查窗口是否创建成功</span><br>    <span class="hljs-keyword">if</span> (window == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-comment">//销毁glfw</span><br>        <span class="hljs-built_in">glfwTerminate</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">//通知glfw将我们窗口的上下文设置为当前线程的主上下文</span><br>    <span class="hljs-built_in">glfwMakeContextCurrent</span>(window);<br>    <span class="hljs-comment">// -----------GLAD加载所有OpenGL函数指针-----------</span><br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">//先前只是生成了窗口的大小，但窗口大小与实际渲染区域无关。因此，我们需要定义渲染区域的大小，即视口(Viewport)。</span><br>    <span class="hljs-comment">//视口定义了窗口中可以渲染的区域，将其设置为窗口的维度</span><br>    <span class="hljs-comment">//前两个参数代表渲染区域左下角在GLFW窗口的坐标。第三个和第四个参数是渲染区域的宽度和高度（像素）</span><br>    <span class="hljs-comment">//注意，这里并没有传入window，所以glViewport是个状态使用函数。</span><br>    <span class="hljs-built_in">glViewport</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">800</span>, <span class="hljs-number">600</span>);<br>    <span class="hljs-comment">//为了让窗口被改变时，视口也能相应改变，我们需要注册一个窗口大小的回调函数</span><br>    <span class="hljs-comment">//glfwSetFramebufferSizeCallback函数接受一个窗口，一个函数指针，当窗口大小改变时调用这个函数</span><br>    <span class="hljs-built_in">glfwSetFramebufferSizeCallback</span>(window,framebuffer_size_callback);<br>    <span class="hljs-comment">// -----------渲染循环-----------</span><br>    <span class="hljs-comment">//当窗口被要求关闭时，glfwWindowShouldClose函数返回true</span><br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">glfwWindowShouldClose</span>(window))&#123;<br>        <span class="hljs-comment">// 清除颜色缓冲</span><br>        <span class="hljs-comment">// glClearColor用来设置清空屏幕所用的颜色</span><br>        <span class="hljs-built_in">glClearColor</span>(<span class="hljs-number">0.2f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">1.0f</span>);<br>        <span class="hljs-comment">// 清除颜色缓冲。除此之外还有GL_DEPTH_BUFFER_BIT，GL_STENCIL_BUFFER_BIT，分别用于清除深度缓冲、模板缓冲</span><br>        <span class="hljs-comment">// glClearColor是状态设置函数，而glClear是状态使用函数</span><br>        <span class="hljs-built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<br>        <span class="hljs-comment">// 调用输入函数，处理键盘输入</span><br>        <span class="hljs-built_in">processInput</span>(window);<br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// 这里放渲染指令...</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// 交换缓冲区(双缓冲区的实现, 用于避免图像闪烁)</span><br>        <span class="hljs-built_in">glfwSwapBuffers</span>(window);<br>        <span class="hljs-comment">// 处理事件，比如键盘和鼠标事件，随后更新窗口状态并调用回调函数</span><br>        <span class="hljs-built_in">glfwPollEvents</span>();<br>    &#125;<br>    <span class="hljs-comment">// -----------清理资源-----------</span><br>    <span class="hljs-built_in">glfwDestroyWindow</span>(window);<br>    <span class="hljs-built_in">glfwTerminate</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>通常的OpenGL范例程序：</p><p>初始化GLFW-&gt;设置GLFW信息，如OpenGL版本号-&gt;生成窗口-&gt;设置线程上下文-&gt;使用GLAD获取GL函数-&gt;定义渲染视口大小-&gt;注册各类回调函数-&gt;进入渲染循环-&gt;销毁资源</p><p>渲染循环内部：</p><p>清空缓存-&gt;处理输入-&gt;进行渲染操作（在后缓冲上绘制）-&gt;检查并调用事件，交换缓冲（使后缓冲的内容显示到画面上）</p></blockquote><blockquote><p>GLFW函数可分为两类：状态设置函数和状态使用函数。前者用于设置状态量，后者用于借助已经设置完毕的状态来改变程序行为。</p></blockquote><h2 id="对象绘制"><a href="#对象绘制" class="headerlink" title="对象绘制"></a>对象绘制</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><blockquote><p>顶点数组对象：Vertex Array Object，VAO</p><p>顶点缓冲对象：Vertex Buffer Object，VBO</p><p>元素缓冲对象：Element Buffer Object，EBO 或 索引缓冲对象 Index Buffer Object，IBO</p></blockquote><p>图形渲染管线可以被分为两个部分：</p><ul><li>第一部分负责将3D坐标转换为2D坐标</li><li>第二部分负责将2D坐标转换为有颜色的，实际屏幕上的像素。</li></ul><blockquote><p>2D坐标与像素不同。像素是2D坐标的近似值，受分辨率影响。</p></blockquote><p>着色器是运行在GPU上的处理程序。每个小核心负责一个着色器的计算。</p><p>Vertex Shader、Geometry Shader和Fragment Shader可以由开发者自定义。</p><p><img src="https://learnopengl-cn.github.io/img/01/04/pipeline.png" alt="img"></p><p>Vertex Shader把单独的顶点作为输入，将局部坐标系下的顶点坐标转换到标准化设备坐标（NDC），同时对顶点属性（Vertex Attribute）进行基本处理。</p><blockquote><p>经Vertex Shader处理过的坐标必定是NDC，范围为[-1, 1]</p></blockquote><p>Geometry Shader把一个图元（包括点、线、三角形三种类型）的顶点作为输入，根据需要处理这些顶点，也可以生成新的顶点，用于构建新的形状。</p><blockquote><p>这个过程可选。</p></blockquote><p>Shape Assembly将前阶段的所有顶点作为输入，并将其装配为指定图元的形状。</p><p>Rasterization把图元映射为屏幕上的像素，生成Fragment, 并剔除View以外的所有像素。</p><blockquote><p>glViewport函数定义了视口信息。视口变换（Viewport Transform）将NDC变换为屏幕空间坐标。</p><p>屏幕空间坐标被变换为Fragment，输入到Fragment Shader中。</p></blockquote><p>Fragment Shader用于计算一个像素的最终颜色。该阶段包含3D场景的数据，如光照、阴影等。</p><p>Test and Blending阶段，首先检测所有像素的深度值、模板值，用于判断像素是正面还是背面，并据此决定是否丢弃。随后，根据像素的alpha值，进行blend操作。</p><h3 id="顶点输入"><a href="#顶点输入" class="headerlink" title="顶点输入"></a>顶点输入</h3><p>顶点数据首先被送到顶点着色器。这些数据以顶点缓冲对象（Vertex Buffer Objects, VBO）的状态存储在GPU内存（即显存）中。</p><blockquote><p>使用VBO的优点在于，可以一次发送一大批数据到GPU上，而非一个顶点传送一次。</p><p>CPU到GPU的传输速度较慢，所以要尽量减少传输次数，一次发送尽可能多的数据。</p></blockquote><p>通过**glGenBuffers(int count, unsigned int* VBO)**函数生成VBO对象。生成完毕后，变量VBO将存储VBO实例的id。随后，进行绑定操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VBO;<br><span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;VBO); <span class="hljs-comment">//生成一个VBO对象，带有缓冲区id</span><br><span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);  <span class="hljs-comment">//将该对象绑定到GL上下文的GL_ARRAY_BUFFER目标</span><br></code></pre></td></tr></table></figure><blockquote><p>任何对象在生成以后都需要与GL上下文中的特定目标进行绑定，才能生效。</p><p>每个缓冲区目标都只能同时绑定一个对象。</p><p>GL_ARRAY_BUFFER存储的对象通常是：需要在CPU和GPU之间传输的顶点相关数据。</p></blockquote><p>**glBufferData(CONTEXT_TARGET, int data_len, float[] data, DRAW_FORM)**用于向当前绑定的缓冲区存入用户定义数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> verticals[] = &#123;<br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,<br>     <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,<br>     <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span><br>&#125;;<br><span class="hljs-built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(verticals),verticals, GL_STATIC_DRAW);<br></code></pre></td></tr></table></figure><blockquote><p>DRAW_FORM参数用于指定显卡如何管理存入的数据。</p><ul><li>GL_STATIC_DRAW：存入的数据几乎不会发生变化</li><li>GL_DYNAMIC_DRAW：存入的数据时常会有发生变化</li><li>GL_STREAM_DRAW：存入的数据每时每刻都在变化</li></ul></blockquote><p>至此，顶点已完成了输入，此刻的顶点数据以VBO的形式存储在显存中。</p><h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core //定义版本号和PROFILE模式</span><br><span class="hljs-comment">//定义一个名为aPos的输入变量，其位置索引为0，类型为vec3。</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos;<br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-comment">//将输入的顶点位置转换为4维向量（齐次坐标），并赋值给内建变量gl_Position，该变量表示顶点着色器的输出位置。</span><br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>location变量用于绑定顶点属性的特定位置索引。一般而言，顶点属性都是用float类型存储的。而存放顶点数据的vertical数组又是一维而非二维的。因此，可能出现前N个数据里，数据[0,N-M]是位置数据，而[N-M+1,N]是颜色数据。通过设置不同的location变量，可以解明顶点数据的具体含义。</p><p>gl_Position的值将会成为顶点着色器的输出。</p><p>在实际的顶点着色器中，往往还需要经过坐标变换到NDC的过程。</p></blockquote><p>C++源码文件无法直接嵌入GLSL代码。所以需要在运行时动态编译。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//顶点着色器源码</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *vertexShaderSource = <span class="hljs-string">&quot;#version 330 core\n&quot;</span><br>    <span class="hljs-string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span><br>    <span class="hljs-string">&quot;void main()\n&quot;</span><br>    <span class="hljs-string">&quot;&#123;\n&quot;</span><br>    <span class="hljs-string">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span><br>    <span class="hljs-string">&quot;&#125;\0&quot;</span>;<br><span class="hljs-comment">//用于保存着色器对象ID引用的无符号整数</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> vertexShader;<br><span class="hljs-comment">//使用glCreateShader函数创建指定类型的着色器对象</span><br><span class="hljs-comment">//由于同种类型的着色器只能生成一个，所以可以直接赋值而非传入地址</span><br>vertexShader = <span class="hljs-built_in">glCreateShader</span>(GL_VERTEX_SHADER);<br><span class="hljs-comment">//对于glShaderSource，其参数含义分别为：着色器对象、源码字符串数量、源码字符串首地址、包含每个字符串长度的整数数组。该函数是把“源码字符串”绑定到“着色器对象”的操作。</span><br><span class="hljs-built_in">glShaderSource</span>(vertexShader, <span class="hljs-number">1</span>, &amp;vertexShaderSource, <span class="hljs-literal">NULL</span>);<br><span class="hljs-comment">//进行编译</span><br><span class="hljs-built_in">glCompileShader</span>(vertexShader);<br></code></pre></td></tr></table></figure><p>通过<code>glGetShaderiv</code>函数可以检测编译是否成功。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>  success; <span class="hljs-comment">//是否成功编译的flag</span><br><span class="hljs-type">char</span> infoLog[<span class="hljs-number">512</span>]; <span class="hljs-comment">//错误信息字符数组</span><br><span class="hljs-comment">//glGetShaderiv用于获取着色器信息</span><br><span class="hljs-comment">//第二个参数可替换为以下选项：</span><br><span class="hljs-comment">//GL_SHADER_TYPE：获取着色器类型</span><br><span class="hljs-comment">//..待补充</span><br><span class="hljs-built_in">glGetShaderiv</span>(vertexShader, GL_COMPILE_STATUS, &amp;success); <span class="hljs-comment">//获取编译结果</span><br><span class="hljs-keyword">if</span>(!success)<br>&#123; <span class="hljs-comment">//若未编译成功</span><br>    <span class="hljs-built_in">glGetShaderInfoLog</span>(vertexShader, <span class="hljs-number">512</span>, <span class="hljs-literal">NULL</span>, infoLog); <span class="hljs-comment">//获取编译错误信息,512代表infoLog数组大小</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl; <span class="hljs-comment">//打印</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="片元着色器"><a href="#片元着色器" class="headerlink" title="片元着色器"></a>片元着色器</h3><p>片元着色器用于计算像素最后的颜色输出。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragColor; <span class="hljs-comment">// 片元着色器允许用户自定义输出变量</span><br><span class="hljs-type">void</span> main()<br>&#123;<br>    FragColor = <span class="hljs-type">vec4</span>(<span class="hljs-number">1.0</span>f, <span class="hljs-number">0.5</span>f, <span class="hljs-number">0.2</span>f, <span class="hljs-number">1.0</span>f); <span class="hljs-comment">//橘黄色</span><br>&#125; <br></code></pre></td></tr></table></figure><p>随后进行编译。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* fragmentShaderSource = <span class="hljs-string">&quot;#version 330 core\n&quot;</span><br>    <span class="hljs-string">&quot;out vec4 FragColor;\n&quot;</span><br>    <span class="hljs-string">&quot;void main()\n&quot;</span><br>    <span class="hljs-string">&quot;&#123;\n&quot;</span><br>    <span class="hljs-string">&quot;FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;</span><br>    <span class="hljs-string">&quot;&#125;\n&quot;</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fragmentShader;<br>fragmentShader = <span class="hljs-built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);<br><span class="hljs-built_in">glShaderSource</span>(fragmentShader, <span class="hljs-number">1</span>, &amp;fragmentShaderSource, <span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">glCompileShader</span>(fragmentShader);<br></code></pre></td></tr></table></figure><h3 id="着色器程序"><a href="#着色器程序" class="headerlink" title="着色器程序"></a>着色器程序</h3><p>完成着色器编译后，还需要编写着色器程序。整个渲染管线就像一个链表，着色器是其中的一个个节点，而着色器程序负责把这些节点连接（Link）起来，并负责数据的输入输出。</p><p>当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当输出和输入不匹配的时候，你会得到一个连接错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> shaderProgram; <span class="hljs-comment">//句柄</span><br>shaderProgram = <span class="hljs-built_in">glCreateProgram</span>();<br><span class="hljs-comment">//注意Attach操作的顺序</span><br><span class="hljs-built_in">glAttachShader</span>(shaderProgram, vertexShader);<br><span class="hljs-built_in">glAttachShader</span>(shaderProgram, fragmentShader);<br><span class="hljs-comment">//完成Attach以后，进行Link操作。</span><br><span class="hljs-built_in">glLinkProgram</span>(shaderProgram);<br></code></pre></td></tr></table></figure><p>借助<code>glGetProgramiv</code>函数，可以判断链接是否出错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">glGetProgramiv</span>(shaderProgram, GL_LINK_STATUS, &amp;success);<br><span class="hljs-keyword">if</span>(!success) &#123;<br>    <span class="hljs-built_in">glGetProgramInfoLog</span>(shaderProgram, <span class="hljs-number">512</span>, <span class="hljs-literal">NULL</span>, infoLog);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>链接完毕后，使用<code>glUseProgram</code>函数激活着色器程序对象，同时，删除先前定义的着色器，以释放内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">glUseProgram</span>(shaderProgram);<br><span class="hljs-built_in">glDeleteShader</span>(vertexShader);<br><span class="hljs-built_in">glDeleteShader</span>(fragmentShader);<br></code></pre></td></tr></table></figure><p>完成这一系列操作以后，我们完成了以下内容：</p><ul><li>发送顶点数据，让其以VBO的状态存储在显存。</li><li>编写了Vertex Shader和Fragment Shader，并指示GPU该如何使用这些着色器处理顶点数据。</li></ul><h3 id="链接顶点属性"><a href="#链接顶点属性" class="headerlink" title="链接顶点属性"></a>链接顶点属性</h3><p>我们输入的verticals数组是一个一维float数组。在这个数组里，每3个元素代表着一个顶点的位置数据。但OpenGL不知道，所以我们要告诉OpenGL，数组的哪些位置代表着哪个顶点的什么属性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//指定解析顶点数据的方式</span><br><span class="hljs-comment">//第一个参数指定我们要配置的顶点属性，即着色器中的location。位置信息是一个location，颜色信息就是另一个location</span><br><span class="hljs-comment">//第二个参数指定顶点数据的大小，也就是每个属性的维度数。位置数据是一个三维向量，所以输入3</span><br><span class="hljs-comment">//第三个参数指定数据的类型</span><br><span class="hljs-comment">//第四个参数指定是否归一化，映射到0-1(或-1到1，对于有符号数来说。)</span><br><span class="hljs-comment">//第五个参数指定步长，即：这个属性第二次出现的地方到整个数组0位置之间有多少字节。对于单一属性数组，可设置为0</span><br><span class="hljs-comment">//第六个参数表示数据在缓冲区相对于起始位置的偏移量。如：位置信息包含3字节，紧随其后的是颜色信息。那么对于位置信息，这个参数就是(void*)0，对于颜色信息就是(void*)3</span><br><span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<br><span class="hljs-comment">//设置完成后，启用顶点属性</span><br><span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">0</span>);<br><span class="hljs-comment">//随后启用着色器程序</span><br><span class="hljs-built_in">glUseProgram</span>(shaderProgram);<br></code></pre></td></tr></table></figure><h3 id="顶点数组对象"><a href="#顶点数组对象" class="headerlink" title="顶点数组对象"></a>顶点数组对象</h3><p>所以，每次绘制一个物体，我们都必须经历以下步骤：</p><ul><li>生成VBO对象</li><li>绑定VBO对象到GL_ARRAY_BUFFER</li><li>将顶点数据（float数组）传入GL_ARRAY_BUFFER</li><li>设置顶点属性指针</li><li>启用顶点属性</li><li>使用着色器程序</li><li>绘制物体</li></ul><p>非常繁琐。为了减少工作量，我们引入顶点数组对象（Vertex Array Object，VAO）的概念。</p><p>一个顶点数组对象会储存以下这些内容：</p><ul><li>glEnableVertexAttribArray和glDisableVertexAttribArray的调用。</li><li>通过glVertexAttribPointer设置的顶点属性配置。</li><li>通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。</li></ul><p>一般，完整的渲染代码可以表示为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ..:: 初始化代码（只运行一次 (除非你的物体频繁改变)） :: ..</span><br><span class="hljs-comment">// 生成VAO、VBO对象....</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VAO;<br><span class="hljs-built_in">glGenVertexArrays</span>(<span class="hljs-number">1</span>, &amp;VAO);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VBO;<br><span class="hljs-built_in">glGenVertexArrays</span>(<span class="hljs-number">1</span>, &amp;VBO);<br><span class="hljs-comment">// 1. 绑定VAO</span><br><span class="hljs-built_in">glBindVertexArray</span>(VAO);<br><span class="hljs-comment">// 2. 把顶点数组复制到缓冲中供OpenGL使用</span><br><span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);<br><span class="hljs-built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<br><span class="hljs-comment">// 3. 设置顶点属性指针</span><br><span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<br><span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">0</span>);<br><span class="hljs-comment">// ..:: 绘制代码（渲染循环中） :: ..</span><br><span class="hljs-comment">// 4. 绘制物体</span><br><span class="hljs-built_in">glUseProgram</span>(shaderProgram);<br><span class="hljs-built_in">glBindVertexArray</span>(VAO);<br><span class="hljs-built_in">someOpenGLFunctionThatDrawsOurTriangle</span>();<br></code></pre></td></tr></table></figure><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p><code>glDrawArray</code>函数使用当前激活的着色器和VAO（包含VBO信息）来绘制图元（点、线、三角）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">glUseProgram</span>(shaderProgram);<br><span class="hljs-built_in">glBindVertexArray</span>(VAO);<br><span class="hljs-comment">// 第一个参数表示图元类型</span><br><span class="hljs-comment">// 第二个参数表示顶点数组起始索引</span><br><span class="hljs-comment">// 第三个表示绘制的顶点数量</span><br><span class="hljs-built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glad/glad.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;GLFW/glfw3.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//顶点数据</span><br><span class="hljs-type">float</span> verticals[] = &#123;<br>        <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,<br>        <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,<br>        <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span><br>&#125;;<br><br><span class="hljs-comment">//顶点着色器源码</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* vertex_shader=<span class="hljs-string">&quot;#version 330 core\n&quot;</span><br>                          <span class="hljs-string">&quot;layout(location=0) in vec3 aPos;\n&quot;</span><br>                          <span class="hljs-string">&quot;void main()\n&quot;</span><br>                          <span class="hljs-string">&quot;&#123;\n&quot;</span><br>                          <span class="hljs-string">&quot;gl_Position = vec4(aPos,1.0);&quot;</span><br>                          <span class="hljs-string">&quot;&#125;\n&quot;</span>;<br><br><span class="hljs-comment">//片段着色器源码</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* fragment_shader=<span class="hljs-string">&quot;#version 330 core\n&quot;</span><br>                            <span class="hljs-string">&quot;out vec4 Fragcolor;\n&quot;</span><br>                            <span class="hljs-string">&quot;void main()\n&quot;</span><br>                            <span class="hljs-string">&quot;&#123;\n&quot;</span><br>                            <span class="hljs-string">&quot;Fragcolor = vec4(1.0f, 0.5f, 0.2f, 1.0f);&quot;</span><br>                            <span class="hljs-string">&quot;&#125;\n&quot;</span>;<br><br><span class="hljs-comment">//输入处理函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process_input</span><span class="hljs-params">(GLFWwindow* window, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span></span>&#123;<br>    <span class="hljs-built_in">glViewport</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,width,height);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//初始化glfw并配置版本和PROFILE模式</span><br>    <span class="hljs-built_in">glfwInit</span>();<br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR,<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR,<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE,GLFW_OPENGL_CORE_PROFILE);<br>    <span class="hljs-comment">//创建glfw窗口</span><br>    GLFWwindow* window = <span class="hljs-built_in">glfwCreateWindow</span>(<span class="hljs-number">800</span>,<span class="hljs-number">600</span>,<span class="hljs-string">&quot;LearnOpenGL&quot;</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">//创建错误处理</span><br>    <span class="hljs-keyword">if</span>(window==<span class="hljs-literal">NULL</span>)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Failed to create GLFW Window!&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-built_in">glfwTerminate</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">//将窗口上下文设置为当前线程上下文</span><br>    <span class="hljs-built_in">glfwMakeContextCurrent</span>(window);<br>    <span class="hljs-comment">//加载glad函数</span><br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Failed to load proc&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">//定义视口大小</span><br>    <span class="hljs-built_in">glViewport</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">800</span>,<span class="hljs-number">600</span>);<br>    <span class="hljs-comment">//配置窗口大小改变的回调函数，使得窗口改变时视口随之改变</span><br>    <span class="hljs-built_in">glfwSetFramebufferSizeCallback</span>(window,process_input);<br>    <span class="hljs-comment">//创建、绑定VBO对象</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VBO;<br>    <span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>,&amp;VBO);<br>    <span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER,VBO);<br>    <span class="hljs-built_in">glBufferData</span>(GL_ARRAY_BUFFER,<span class="hljs-built_in">sizeof</span>(verticals),verticals,GL_STATIC_DRAW);<br>    <span class="hljs-comment">//创建、绑定VAO对象</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VAO;<br>    <span class="hljs-built_in">glGenVertexArrays</span>(<span class="hljs-number">1</span>,&amp;VAO);<br>    <span class="hljs-built_in">glBindVertexArray</span>(VAO);<br>    <span class="hljs-comment">//配置顶点属性指针，说明顶点数据与属性的对应关系</span><br>    <span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,GL_FLOAT,GL_FALSE,<span class="hljs-number">0</span>,(<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//启用顶点属性</span><br>    <span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//创建顶点着色器</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> vertex = <span class="hljs-built_in">glCreateShader</span>(GL_VERTEX_SHADER);<br>    <span class="hljs-comment">//链接着色器对象与源代码</span><br>    <span class="hljs-built_in">glShaderSource</span>(vertex,<span class="hljs-number">1</span>,&amp;vertex_shader,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">//编译着色器</span><br>    <span class="hljs-built_in">glCompileShader</span>(vertex);<br>    <span class="hljs-type">int</span>  success; <span class="hljs-comment">//是否成功编译的flag</span><br>    <span class="hljs-type">char</span> infoLog[<span class="hljs-number">512</span>]; <span class="hljs-comment">//错误信息字符数组</span><br>    <span class="hljs-built_in">glGetShaderiv</span>(vertex, GL_COMPILE_STATUS, &amp;success); <span class="hljs-comment">//获取编译结果</span><br>    <span class="hljs-keyword">if</span>(!success)<br>    &#123; <span class="hljs-comment">//若未编译成功</span><br>        <span class="hljs-built_in">glGetShaderInfoLog</span>(vertex, <span class="hljs-number">512</span>, <span class="hljs-literal">NULL</span>, infoLog); <span class="hljs-comment">//获取编译错误信息,512代表infoLog数组大小</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl; <span class="hljs-comment">//打印</span><br>    &#125;<br>    <span class="hljs-comment">//同上</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fragment = <span class="hljs-built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);<br>    <span class="hljs-built_in">glShaderSource</span>(fragment,<span class="hljs-number">1</span>,&amp;fragment_shader,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">glCompileShader</span>(fragment);<br>    <span class="hljs-built_in">glGetShaderiv</span>(fragment, GL_COMPILE_STATUS, &amp;success); <span class="hljs-comment">//获取编译结果</span><br>    <span class="hljs-keyword">if</span>(!success)<br>    &#123; <span class="hljs-comment">//若未编译成功</span><br>        <span class="hljs-built_in">glGetShaderInfoLog</span>(fragment, <span class="hljs-number">512</span>, <span class="hljs-literal">NULL</span>, infoLog); <span class="hljs-comment">//获取编译错误信息,512代表infoLog数组大小</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl; <span class="hljs-comment">//打印</span><br>    &#125;<br>    <span class="hljs-comment">//创建着色器程序</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> shader_program = <span class="hljs-built_in">glCreateProgram</span>();<br>    <span class="hljs-comment">//添加着色器“节点”，注意顺序</span><br>    <span class="hljs-built_in">glAttachShader</span>(shader_program,vertex);<br>    <span class="hljs-built_in">glAttachShader</span>(shader_program,fragment);<br>    <span class="hljs-comment">//完成链接操作</span><br>    <span class="hljs-built_in">glLinkProgram</span>(shader_program);<br>    <span class="hljs-comment">//激活着色器程序</span><br>    <span class="hljs-built_in">glUseProgram</span>(shader_program);<br>    <span class="hljs-comment">//删除着色器对象，释放内存</span><br>    <span class="hljs-built_in">glDeleteShader</span>(vertex);<br>    <span class="hljs-built_in">glDeleteShader</span>(fragment);<br>    <span class="hljs-comment">//渲染循环</span><br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">glfwWindowShouldClose</span>(window))&#123;<br>        <span class="hljs-comment">//设置清空颜色</span><br>        <span class="hljs-built_in">glClearColor</span>(<span class="hljs-number">0.2f</span>,<span class="hljs-number">0.3f</span>,<span class="hljs-number">0.3f</span>,<span class="hljs-number">1.0f</span>);<br>        <span class="hljs-comment">//清空上一帧</span><br>        <span class="hljs-built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<br>        <span class="hljs-comment">//激活着色器程序</span><br>        <span class="hljs-built_in">glUseProgram</span>(shader_program);<br>        <span class="hljs-comment">//绑定VAO对象</span><br>        <span class="hljs-built_in">glBindVertexArray</span>(VAO);<br>        <span class="hljs-comment">//绘制三个顶点的三角形图元</span><br>        <span class="hljs-built_in">glDrawArrays</span>(GL_TRIANGLES,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">//交换前后缓冲</span><br>        <span class="hljs-built_in">glfwSwapBuffers</span>(window);<br>        <span class="hljs-comment">//处理外部输入</span><br>        <span class="hljs-built_in">glfwPollEvents</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="元素缓冲对象"><a href="#元素缓冲对象" class="headerlink" title="元素缓冲对象"></a>元素缓冲对象</h3><p>当图元存在共用顶点的情况时，传统的绘制方法会把共用的顶点绘制两次，导致额外开销。</p><p>为此，元素缓冲对象（Element Buffer Object, EBO）提供了一种方式，用于存储OpenGL用来决定要绘制哪些顶点的索引。</p><p>使用EBO时，顶点数据必须是不重复的顶点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> vertices[] = &#123;<br>    <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// 右上角</span><br>    <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// 右下角</span><br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">// 左下角</span><br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>   <span class="hljs-comment">// 左上角</span><br>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> indices[] = &#123;<br>    <span class="hljs-comment">// 注意索引从0开始! </span><br>    <span class="hljs-comment">// 此例的索引(0,1,2,3)就是顶点数组vertices的下标，</span><br>    <span class="hljs-comment">// 这样可以由下标代表顶点组合成矩形</span><br>    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-comment">// 第一个三角形</span><br>    <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>  <span class="hljs-comment">// 第二个三角形</span><br>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> EBO;<br><span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;EBO);<br><span class="hljs-built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);<br><span class="hljs-built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);<br><span class="hljs-comment">//渲染循环内...</span><br><span class="hljs-built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);<br><span class="hljs-built_in">glDrawElements</span>(GL_TRIANGLES, <span class="hljs-number">6</span>, GL_UNSIGNED_INT, <span class="hljs-number">0</span>); <span class="hljs-comment">//注意，使用EBO时需要使用glDrawElements。其中，第四个参数表示EBO中的偏移量。</span><br></code></pre></td></tr></table></figure><p>使用EBO的完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glad/glad.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;GLFW/glfw3.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">float</span> vertices[] = &#123;<br>        <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// 右上角</span><br>        <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// 右下角</span><br>        <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">// 左下角</span><br>        <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>   <span class="hljs-comment">// 左上角</span><br>&#125;;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> indices[] = &#123;<br>        <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-comment">// 第一个三角形</span><br>        <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>  <span class="hljs-comment">// 第二个三角形</span><br>&#125;;<br><br><span class="hljs-comment">//顶点着色器源码</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* vertex_shader=<span class="hljs-string">&quot;#version 330 core\n&quot;</span><br>                          <span class="hljs-string">&quot;layout(location=0) in vec3 aPos;\n&quot;</span><br>                          <span class="hljs-string">&quot;void main()\n&quot;</span><br>                          <span class="hljs-string">&quot;&#123;\n&quot;</span><br>                          <span class="hljs-string">&quot;gl_Position = vec4(aPos,1.0);&quot;</span><br>                          <span class="hljs-string">&quot;&#125;\n&quot;</span>;<br><br><span class="hljs-comment">//片段着色器源码</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* fragment_shader=<span class="hljs-string">&quot;#version 330 core\n&quot;</span><br>                            <span class="hljs-string">&quot;out vec4 Fragcolor;\n&quot;</span><br>                            <span class="hljs-string">&quot;void main()\n&quot;</span><br>                            <span class="hljs-string">&quot;&#123;\n&quot;</span><br>                            <span class="hljs-string">&quot;Fragcolor = vec4(1.0f, 0.5f, 0.2f, 1.0f);&quot;</span><br>                            <span class="hljs-string">&quot;&#125;\n&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process_input</span><span class="hljs-params">(GLFWwindow* window,<span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span></span>&#123;<br>    <span class="hljs-built_in">glViewport</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,width,height);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">glfwInit</span>();<br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR,<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR,<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE,GLFW_OPENGL_CORE_PROFILE);<br>    GLFWwindow* window = <span class="hljs-built_in">glfwCreateWindow</span>(<span class="hljs-number">800</span>,<span class="hljs-number">600</span>,<span class="hljs-string">&quot;LearnOpenGL&quot;</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(window==<span class="hljs-literal">NULL</span>)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Failed to Create Window&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-built_in">glfwTerminate</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">glfwMakeContextCurrent</span>(window);<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">gladLoadGLLoader</span>((GLADloadproc) glfwGetProcAddress))&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Failed to Load GLAD proc&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-built_in">glfwTerminate</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">glViewport</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">800</span>,<span class="hljs-number">600</span>);<br>    <span class="hljs-built_in">glfwSetFramebufferSizeCallback</span>(window,process_input);<br><br>    <span class="hljs-comment">//编译着色器</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> vertex = <span class="hljs-built_in">glCreateShader</span>(GL_VERTEX_SHADER);<br>    <span class="hljs-built_in">glShaderSource</span>(vertex,<span class="hljs-number">1</span>,&amp;vertex_shader,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">glCompileShader</span>(vertex);<br>    <span class="hljs-type">int</span> success;<br>    <span class="hljs-type">char</span> info[<span class="hljs-number">512</span>];<br>    <span class="hljs-built_in">glGetShaderiv</span>(vertex,GL_COMPILE_STATUS,&amp;success);<br>    <span class="hljs-keyword">if</span>(!success)&#123;<br>        <span class="hljs-built_in">glad_glGetShaderInfoLog</span>(vertex,<span class="hljs-number">512</span>,<span class="hljs-literal">NULL</span>,info);<br>        cout&lt;&lt;<span class="hljs-string">&quot;VERTEX SHADER COMPILE ERROR:&quot;</span>&lt;&lt;info&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fragment = <span class="hljs-built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);<br>    <span class="hljs-built_in">glShaderSource</span>(fragment,<span class="hljs-number">1</span>,&amp;fragment_shader,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">glCompileShader</span>(fragment);<br>    <span class="hljs-built_in">glGetShaderiv</span>(fragment,GL_COMPILE_STATUS,&amp;success);<br>    <span class="hljs-keyword">if</span>(!success)&#123;<br>        <span class="hljs-built_in">glad_glGetShaderInfoLog</span>(fragment,<span class="hljs-number">512</span>,<span class="hljs-literal">NULL</span>,info);<br>        cout&lt;&lt;<span class="hljs-string">&quot;FRAGMENT SHADER COMPILE ERROR:&quot;</span>&lt;&lt;info&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> shader_program = <span class="hljs-built_in">glCreateProgram</span>();<br>    <span class="hljs-built_in">glAttachShader</span>(shader_program,vertex);<br>    <span class="hljs-built_in">glAttachShader</span>(shader_program,fragment);<br>    <span class="hljs-built_in">glLinkProgram</span>(shader_program);<br>    <span class="hljs-built_in">glGetProgramiv</span>(shader_program, GL_LINK_STATUS, &amp;success);<br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>        <span class="hljs-built_in">glGetProgramInfoLog</span>(shader_program, <span class="hljs-number">512</span>, <span class="hljs-literal">NULL</span>, info);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&quot;</span> &lt;&lt; info &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-built_in">glDeleteShader</span>(vertex);<br>    <span class="hljs-built_in">glDeleteShader</span>(fragment);<br><br>    <span class="hljs-comment">//定义VAO、VBO、EBO</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VBO;<br>    <span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>,&amp;VBO);<br>    <span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER,VBO);<br>    <span class="hljs-built_in">glBufferData</span>(GL_ARRAY_BUFFER,<span class="hljs-built_in">sizeof</span>(vertices),vertices,GL_STATIC_DRAW);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VAO;<br>    <span class="hljs-built_in">glGenVertexArrays</span>(<span class="hljs-number">1</span>,&amp;VAO);<br>    <span class="hljs-built_in">glBindVertexArray</span>(VAO);<br>    <span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,GL_FLOAT,GL_FALSE,<span class="hljs-number">0</span>,(<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> EBO;<br>    <span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>,&amp;EBO);<br>    <span class="hljs-built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER,EBO);<br>    <span class="hljs-built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER,<span class="hljs-built_in">sizeof</span>(indices),indices,GL_STATIC_DRAW);<br>    <span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">glBindVertexArray</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">glfwWindowShouldClose</span>(window))&#123;<br>        <span class="hljs-built_in">glClearColor</span>(<span class="hljs-number">0.5f</span>,<span class="hljs-number">0.4f</span>,<span class="hljs-number">0.3f</span>,<span class="hljs-number">1.0f</span>);<br>        <span class="hljs-built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<br>        <span class="hljs-built_in">glBindVertexArray</span>(VAO);<br>        <span class="hljs-built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER,EBO);<br>        <span class="hljs-built_in">glUseProgram</span>(shader_program);<br>        <span class="hljs-built_in">glDrawElements</span>(GL_TRIANGLES,<span class="hljs-number">6</span>,GL_UNSIGNED_INT,<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">glBindVertexArray</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER,<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">glfwSwapBuffers</span>(window);<br>        <span class="hljs-built_in">glfwPollEvents</span>();<br>    &#125;<br>    <span class="hljs-built_in">glDeleteBuffers</span>(<span class="hljs-number">1</span>,&amp;VBO);<br>    <span class="hljs-built_in">glDeleteProgram</span>(shader_program);<br>    <span class="hljs-built_in">glDeleteVertexArrays</span>(<span class="hljs-number">1</span>,&amp;VAO);<br>    <span class="hljs-built_in">glfwTerminate</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>图形学</tag>
      
      <tag>OpenGL</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pytorch基础</title>
    <link href="/2024/07/09/Pytorch%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/07/09/Pytorch%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>新领域，新气象。<br>    <span id="more"></span></p><h1 id="PyTorch入门"><a href="#PyTorch入门" class="headerlink" title="PyTorch入门"></a>PyTorch入门</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在PyCharm中配置PyTorch时，需要使用本地解释器而非venv虚拟环境中的解释器，否则会出现torch.cuda.is_available()为False的情况。</p><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="torch-reshape"><a href="#torch-reshape" class="headerlink" title="torch.reshape()"></a>torch.reshape()</h3><p><code>torch.reshape(input, shape)</code>：将输入Tensor变为形状为shape的Tensor</p><h2 id="数据加载"><a href="#数据加载" class="headerlink" title="数据加载"></a>数据加载</h2><h3 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h3><p>用于存储和管理数据的类。</p><p><code>torch.utils.data.Dataset</code>是pytorch提供的抽象类。通过继承此类，可自定义另外的Dataset类。</p><p>通过重写<code>__len()__</code>和<code>__getitem__()</code>方法，可返回数据集的大小和每个数据样本及其Label。</p><p>Dataset类中一般必定存在一个成员变量，该变量是一个列表，存放数据的文件路径。</p><p><code>__getitem__()</code>方法通常返回一个Tuple，元素0为数据内容，元素1为Label。</p><blockquote><p><code>__getitem__()</code>方法无需手动调用，在变量后加[idx]即可。类似于索引访问数组。</p><p>通常，<code>__getitem__()</code>方法根据idx从文件路径列表中取出对应的路径，进而根据路径获取数据本身。</p></blockquote><p>通过运算符<code>+</code>，可以将两个Dataset作为一个列表的两个元素，构成一个2D的更大的Dataset。</p><h3 id="Dataloader"><a href="#Dataloader" class="headerlink" title="Dataloader"></a>Dataloader</h3><p>用于从Dataset中为模型加载数据的类。</p><p><code>torch.utils.data.DataLoader</code>提供了创建DataLoader对象的方法。</p><p><code>DataLoader(dataset, batch_size, shuffle, sampler, batch_sampler, num_workers, drop_last)</code></p><blockquote><p>dataset: 数据集实例。</p><p>batch_size：批处理大小，默认为1.</p><p>shuffle：每次训练过后是否将数据集打乱。</p><p>sampler：</p><p>batch_sampler：</p><p>num_workers：进程数。</p><p>drop_last：数据集大小&#x2F;batch_size除不尽时，余数是否丢弃。</p></blockquote><p><code>DataLoader</code>实例是一个迭代器，每个item都是一个2元素元组。</p><p>元素0是一个列表，包含了batch_size个数据。</p><p>元素1是一个列表，包含了batch_size个Label。</p><h2 id="TensorBoard"><a href="#TensorBoard" class="headerlink" title="TensorBoard"></a>TensorBoard</h2><h3 id="SummaryWriter"><a href="#SummaryWriter" class="headerlink" title="SummaryWriter"></a>SummaryWriter</h3><p><code>from torch.utils.tensorboard import SummarWriter</code></p><p><code> SummaryWriter(str)</code>实例化了一个存储在<code>str</code>文件夹中的<code> SummaryWriter</code>对象。</p><p><code> SummaryWriter</code>类用于在训练过程中向文件写入各类信息。这类信息可以被TensorBoard解析并以可视化的方式呈现。</p><h4 id="add-scalar"><a href="#add-scalar" class="headerlink" title="add_scalar()"></a>add_scalar()</h4><p><code>def add_scalar(self, tag, scalar_value, global_step=None, walltime=None)</code></p><blockquote><p><code>tag</code>是对数据的标识符。</p><p><code>scalar_value</code>是要添加的数据。</p><p><code>global_step</code>是当前训练的步数。</p></blockquote><h4 id="add-image"><a href="#add-image" class="headerlink" title="add_image()"></a>add_image()</h4><p><code>def add_image(self, tag, img_tensor, global_step=None, walltime=None, dataformats=‘CHW’)</code></p><blockquote><p><code>tag</code>是对图片数据的标识符。</p><p><code>img_tensor</code>是图片数据。可以为<code>Tensor</code>、<code>ndarray</code>或<code>string</code>。</p><p>使用<code>np.array(PIL.JpegImageFile)</code>即可将PIL图片转换为<code>ndarray</code>。</p><blockquote><p>此种方式转换的ndarray的shape为（H, W, C），即三个维度分别对应高度、宽度和通道。</p><p>因此，此时add_image的dataformats参数应当为‘HWC’。</p></blockquote><p>也可用torchvision.transforms.ToTensor()将PIL图片转化为Tensor。</p><p>也可用cv.imread将PIL图片转化为CHW的ndarray。</p></blockquote><h4 id="add-graph"><a href="#add-graph" class="headerlink" title="add_graph()"></a>add_graph()</h4><p><code>add_graph(model, input_to_model=None, verbose=False)</code></p><h2 id="Transforms"><a href="#Transforms" class="headerlink" title="Transforms"></a>Transforms</h2><p><code>from torchvision import transforms</code></p><p><code>transforms</code>用于对图片数据进行变换。该模块内置了若干工具类，</p><h3 id="Compose"><a href="#Compose" class="headerlink" title="Compose()"></a><code>Compose()</code></h3><p><code>Compose(list of transforms object)</code>用于组合多个transforms对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">operation = transforms.Compose([transforms.CenterCrop(<span class="hljs-number">10</span>), transforms.ToTensor()])<br><span class="hljs-comment"># 对图片进行operation操作时，先将其中心裁剪，再将其转换为Tensor对象</span><br></code></pre></td></tr></table></figure><h3 id="ToTensor"><a href="#ToTensor" class="headerlink" title="ToTensor()"></a><code>ToTensor()</code></h3><p><code>ToTensor()</code>用于将对象转换为<code>Tensor</code>对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用PIL打开本地图片，使用ToTensor转换为Tensor对象，再用Tensorboard写入事件文件。</span><br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms<br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><br>img = Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">r&quot;data/img/1.jpg&quot;</span>)<br>totensor_operation = transforms.ToTensor()<br>img_tensor = totensor_operation(img)<br>writer = SummaryWriter(<span class="hljs-string">&quot;test&quot;</span>)<br>writer.add_image(<span class="hljs-string">&quot;测试图片&quot;</span>,img_tensor)<br>writer.close()<br></code></pre></td></tr></table></figure><h3 id="ToPILImage"><a href="#ToPILImage" class="headerlink" title="ToPILImage()"></a><code>ToPILImage()</code></h3><p>将<code>ndarray</code>或<code>Tensor</code>对象转换为PILImage。</p><h3 id="Normalize"><a href="#Normalize" class="headerlink" title="Normalize()"></a><code>Normalize()</code></h3><p>使用z-score法将Tensor对象标准化。</p><p><code>transforms.Normalize(mean=list, std=list)</code></p><blockquote><p>对于mean和std，图片有几个通道，它们就是有几个元素的list。</p><p>list各元素的值需要对数据集中的每个元素的每个通道计算得出。</p></blockquote><p>输出：(原始值-均值)&#x2F;标准差</p><p>作用：将图像的数据分布转换为标准正态分布。</p><p><img src="https://yoi-note.oss-cn-chengdu.aliyuncs.com/Image/202404271416967.png" alt="image-20240427141609922"></p><h3 id="Resize"><a href="#Resize" class="headerlink" title="Resize()"></a><code>Resize()</code></h3><p>将给定的PILImage变换至指定尺寸。</p><p><code>transforms.Resize(size)</code>实例化了一个Resize操作对象。</p><blockquote><p>当size为2元素列表时，第一个元素是高，第二个元素是宽。</p><p>当size为int时，图片更小的边将被缩放至int。</p></blockquote><p><code>transforms.Resize(img)</code>用于将已实例化的缩放操作应用于PILImage。接收的参数可为PILImage，也可为Tensor。</p><h3 id="RandomCrop"><a href="#RandomCrop" class="headerlink" title="RandomCrop()"></a><code>RandomCrop()</code></h3><p>根据给定的size随机裁剪原图片。</p><p><code>transforms.RandomCrop(size)</code>实例化了一个RandomCrop对象。</p><blockquote><p>可选参数：padding：int，2元素列表或4元素列表。分别对应：</p><ul><li>在图片四周添加int像素的间隔。</li><li>在图片左右添加[0]像素间隔，上下添加[1]像素间隔。</li><li>在图片上下左右分别添加[0]、[1]、[2]、[3]像素间隔。</li></ul><p>pad_if_needed：布尔值，当裁剪大小大于图片大小时，自动添加padding。</p><p>fill：int或3元素列表，用于填充padding的像素色。分别对应：RGB（int, int, int）和RGB（r, g, b)</p></blockquote><p><code>transforms.RandomCrop(img)</code>用于执行裁剪操作。</p><h2 id="torchvision数据集"><a href="#torchvision数据集" class="headerlink" title="torchvision数据集"></a>torchvision数据集</h2><p>以<code>CIFAR10</code>数据集为例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torchvision<br><br>train_set = torchvision.datasets.CIFAR10(root=<span class="hljs-string">&quot;dataset&quot;</span>, train=<span class="hljs-literal">True</span>, download=<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># root为存放数据集的根目录;train为是否训练集;download为是否从网络下载数据集。</span><br>test_set = torchvision.datasets.CIFAR10(root=<span class="hljs-string">&quot;dataset&quot;</span>, train=<span class="hljs-literal">False</span>, download=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><blockquote><p>除上述属性外，还有：</p><p><code>transform</code>属性：可传入<code>transforms</code>函数，对数据进行预处理。</p></blockquote><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><h2 id="nn-Module"><a href="#nn-Module" class="headerlink" title="nn.Module"></a><code>nn.Module</code></h2><p><code>nn.Module</code>是所有神经网络的基类。</p><p>自定义一个神经网络类，首先要做的便是继承<code>nn.Module</code>，随后实现<code>__init__()</code>和<code>forward()</code>函数。</p><p>实现<code>__init__()</code>函数时，首先要调用<code>super().__init__()</code>。其中classname为自定义类的类名。</p><p><code>forward()</code>函数实现了前向传播。它接收一个<code>x</code>参数输入，对<code>x</code>进行一系列处理之后返回。</p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyNetwork</span>(nn.Module):<br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>     <span class="hljs-built_in">super</span>(MyNetwork, self).__init__()<br>     <span class="hljs-comment"># 将各层操作作为变量存储</span><br>     self.layerfunction1 = nn.Conv2d(...)<br>     ...<br><br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>     output = self.xxxfunction(x)<br>     <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure></blockquote><h2 id="nn-Sequential"><a href="#nn-Sequential" class="headerlink" title="nn.Sequential"></a><code>nn.Sequential</code></h2><p><code>Sequential</code>用于保存一系列层操作，如卷积、非线性激活、池化等。类似于Transforms的Compose。</p><p><code>model = nn.Sequential(nn.Conv2d(1,20,5),nn.ReLU(),nn.Conv2d(20,64,5),nn.ReLu)</code></p><blockquote><p>输入x可省略。</p></blockquote><h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><p>卷积（Convolution）是让两个函数经过变换得到第三个函数的过程。</p><p><img src="https://yoi-note.oss-cn-chengdu.aliyuncs.com/Image/202404292040281.png" alt="image-20240429204022080"></p><p><code>torch.nn.function</code>模块中，提供了从1D到3D数据的卷积函数：<code>conv1d()</code>、<code>conv2d</code>和<code>conv3d</code>。</p><p>以<code>conv2d()</code>为例：</p><p><code>conv2d(input, weight, bias=None, stride=1, padding=0, dilation=1, groups=1) -&gt; Tensor</code></p><blockquote><p><code>input</code>为输入的Tensor。在CV中，这个Tensor一般是2DTensor，是Image经过ToTensor()变换的结果。</p><blockquote><p>对于input的Tensor，其形状必须满足<code>(minibatch, in_channels, iH, iW)</code></p><p><code>minibatch</code>是<code>DataLoader</code>的<code>batch_size</code>。</p><p><code>in_channels</code>是图片的通道数。</p><p><code>iH</code>、<code>iW</code>分别是图片的高和宽。</p></blockquote><p><code>weight</code>权重，又叫卷积核。</p><blockquote><img src="https://yoi-note.oss-cn-chengdu.aliyuncs.com/Image/202404292143205.png" alt="image-20240429214304139" style="zoom:50%;" /><p>卷积核就像一个遮罩，对输入图像的局部进行处理。卷积核上元素值的不同，卷积结果就不同。元素值就是一个个权重。</p><p>权重的形状必须满足<code>(out_channels, in_channels/groups, kH, kW)</code></p><p><code>out_channels</code>是输出图片的通道数。</p></blockquote><p><code>bias</code>偏置。</p><p><code>stride</code>步进。直观来讲，步进是卷积核在输入图像上方每次移动的像素数。</p><blockquote><p>步进既可以是一个数，也可以是元组(sH, sW)。前者是横向移动的元素数，后者是纵向移动的元素数。</p></blockquote><p><code>padding</code>间隔。直观来讲，对输入图片的边缘进行填充，便于对边缘像素进行卷积处理。</p><blockquote><p>间隔既可以是一个数，也可以是元组(padH, padW)。前者是横向填充的元素数，后者是纵向填充的元素数。</p></blockquote><p><code>dilation</code></p><p><code>groups</code></p></blockquote><h2 id="结构-层"><a href="#结构-层" class="headerlink" title="结构&#x2F;层"></a>结构&#x2F;层</h2><p>可以把每个函数看作一个层。</p><h3 id="卷积层（Convolution-Layer）"><a href="#卷积层（Convolution-Layer）" class="headerlink" title="卷积层（Convolution Layer）"></a>卷积层（Convolution Layer）</h3><p><code>torch.nn</code>提供了<code>torch.nn.function</code>中各功能的简化版本。</p><p><code>Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True, padding_mode=‘zeros’)</code></p><blockquote><p><a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md">conv_arithmetic&#x2F;README.md at master · vdumoulin&#x2F;conv_arithmetic (github.com)</a></p><p>in_channels：输入通道数</p><p>out_channels：输出通道数</p><blockquote><p>即卷积核个数。</p></blockquote><p>kernel_size：卷积核尺寸。可变量，会在训练过程中自行改变。</p><p>stride：步进数</p><p>padding：边缘补充</p><p>dilation：让卷积核的各元素之间间隔一定距离。用于空洞卷积。</p><blockquote> <img src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/dilation.gif" alt="img" style="zoom: 33%;" /></blockquote><p>groups：用于分组卷积</p><p>bias：偏置。</p></blockquote><h3 id="池化层（Pooling-Layer）"><a href="#池化层（Pooling-Layer）" class="headerlink" title="池化层（Pooling Layer）"></a>池化层（Pooling Layer）</h3><p>池化层将一个窗口内的所有信息浓缩为一个输出。它一般在卷积后进行，输入和输出的通道相同，不可改变。因此，输出尺寸会减小，参数减小，助于减少过拟合、提高性能。</p><blockquote><p>卷积核平移的过程，可看作滑动窗口过程。卷积核就是窗口。</p></blockquote><p>对于最大池化（Max Pooling）操作，它取一个窗口内最大的值输出，然后步进。</p><p><code>MaxPool2d(kernel_size, stride=None, padding=0*, dilation=1*, return_indices=False*, ceil_mode=False)</code></p><blockquote><p>return_indices：</p><p>ceil_mode：True时，使用ceil模式（允许出界）；否则使用floor模式（出界池化丢弃）。</p><p>stride：<strong>池化核的步长默认为核大小</strong></p></blockquote><p>平均池化（Mean Pooling）操作计算窗口内平均值输出，然后步进。</p><h3 id="填充层（Padding-Layer）"><a href="#填充层（Padding-Layer）" class="headerlink" title="填充层（Padding Layer）"></a>填充层（Padding Layer）</h3><p>类似于卷积和池化操作中的<code>Padding</code>参数。不同的是，<code>Padding</code>只能填充0，而填充层可以填充其他常数。</p><h3 id="非线性激活（Non-linear-Activations）"><a href="#非线性激活（Non-linear-Activations）" class="headerlink" title="非线性激活（Non-linear Activations）"></a>非线性激活（Non-linear Activations）</h3><h4 id="线性整流函数（ReLU）"><a href="#线性整流函数（ReLU）" class="headerlink" title="线性整流函数（ReLU）"></a>线性整流函数（ReLU）</h4><p><code>torch.nn.ReLU(x)</code>：等效于<code>max(0,x)</code>。</p><blockquote><p><code>inplace</code>参数（bool）：为True则修改传入值；否则传出新值，传入值不变。</p></blockquote><h4 id="Sigmoid函数"><a href="#Sigmoid函数" class="headerlink" title="Sigmoid函数"></a>Sigmoid函数</h4><p><code>torch.nn.Sigmoid(x)</code>：等效于：<code>1/(1+exp(-x))</code>。</p><h3 id="正则化层（Normalization-Layer）"><a href="#正则化层（Normalization-Layer）" class="headerlink" title="正则化层（Normalization Layer）"></a>正则化层（Normalization Layer）</h3><p>用于提高网络性能。</p><p><a href="https://blog.csdn.net/qq_41915623/article/details/125984629">pytorch中对BatchNorm2d()函数的理解-CSDN博客</a></p><p><code>torch.nn.BatchNorm2d(num_features, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, device=None, dtype=None)</code></p><blockquote><p>num_features：通道数。</p><p>eps：稳定值，避免分母为0，默认为1e-5。</p><p>momentum：将历史batch的均值与方差的影响延续到当前batch。</p><p>affine：True时，给定可以学习的系数矩阵Gamma和Beta。</p></blockquote><h3 id="线性层（Linear-Layer）"><a href="#线性层（Linear-Layer）" class="headerlink" title="线性层（Linear Layer）"></a>线性层（Linear Layer）</h3><p><code>torch.nn.Linear(in_features, out_features, bias=True)</code></p><p>对输入施加线性变换：<img src="https://yoi-note.oss-cn-chengdu.aliyuncs.com/Image/202405021536109.png" alt="image-20240502153650043" style="zoom:50%;" /></p><blockquote><p><strong>feature</strong>：特征。对事物进行分类或识别的本质就是提取特征。</p><p>在神经网络中，in_features指的是输入的数组。out_features则反之。</p><p>在Linear函数中，前两个参数分别是输入数组的元素个数和输出数组的元素个数。</p></blockquote><h3 id="丢弃层（Dropout-Layer）"><a href="#丢弃层（Dropout-Layer）" class="headerlink" title="丢弃层（Dropout Layer）"></a>丢弃层（Dropout Layer）</h3><p>防止过拟合。</p><p><code>torch.nn.Dropout2d(p=0.5, inplace=False)</code></p><p>随机将某些元素按p的概率设为0。</p><h3 id="嵌入层（Embedding-Layer）"><a href="#嵌入层（Embedding-Layer）" class="headerlink" title="嵌入层（Embedding Layer）"></a>嵌入层（Embedding Layer）</h3><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>损失函数（Loss Function）用于衡量实际输出与预期输出之间的差距，并用误差值指导模型进行进一步训练学习（即反向传播）。</p><h3 id="L1Loss"><a href="#L1Loss" class="headerlink" title="L1Loss()"></a><code>L1Loss()</code></h3><p><code>torch.nn.L1Loss(input, tartget, reduction=&#39;mean&#39;)</code></p><blockquote><p>input和target的形状为（*, *)。输出一个标量。</p><p>reduction：处理方式。‘mean’则将每个元素的MAE相加并处以元素数量。‘sum’只相加。</p></blockquote><p>比较每个元素的平均绝对误差（Mean Absolute Error, MAE）。</p><blockquote><p>output &#x3D; (|x - x’|+|y - y’| + …)&#x2F;N</p></blockquote><h3 id="SmoothL1Loss"><a href="#SmoothL1Loss" class="headerlink" title="SmoothL1Loss()"></a><code>SmoothL1Loss()</code></h3><img src="https://yoi-note.oss-cn-chengdu.aliyuncs.com/Image/202405031327320.png" alt="image-20240503132740254" style="zoom: 67%;" /><p><code>torch.nn.SmoothL1Loss(reduction=&#39;mean&#39;, beta=1.0)</code></p><p>平滑版的L1Loss。</p><p>当MAE小于1时，返回MSE的0.5倍；否则返回MAE-0.5。结合了L1和MSE的部分优点，适合多数情况。</p><h3 id="MSELoss"><a href="#MSELoss" class="headerlink" title="MSELoss()"></a><code>MSELoss()</code></h3><p><code>torch.nn.MSELoss(reduction=&#39;mean&#39;)</code></p><blockquote><p>input和target的形状为（*, *)。输出一个标量。</p></blockquote><p>比较每个元素的均方差。</p><blockquote><p>output &#x3D; (|x - x’|^2+|y - y’|^2 + …)&#x2F;N</p></blockquote><h3 id="CrossEntropyLoss"><a href="#CrossEntropyLoss" class="headerlink" title="CrossEntropyLoss()"></a><code>CrossEntropyLoss()</code></h3><p><code>torch.nn.CrossEntropyLoss(weight=None, ignore_index=-100, reduction=&#39;mean&#39;, label_smoothing=0.0)</code></p><p>比较预期输出和实际输出的交叉熵。在分类问题中常用。</p><img src="https://yoi-note.oss-cn-chengdu.aliyuncs.com/Image/202405031400362.png" alt="image-20240503140023311" style="zoom:50%;" /><blockquote><p>input的形状需要是（N, C）或(C, C)，其中N为batch_size，C为分类的类别数。</p></blockquote><h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><p> 对损失函数的结果调用<code>backward()</code>子方法即可。</p><p>反向传播用于计算损失函数梯度。得到梯度以后，使用优化器对参数进行更新。</p><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p><a href="https://pytorch.org/docs/main/optim.html">torch.optim — PyTorch main documentation</a></p><p>以<code>torch.optim.SGD()</code>为例：</p><ul><li>实例化优化器对象：<code>optimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.9)</code><ul><li>model.parameters()：nn.Module的parameters()函数。</li><li>lr：学习速率。一般训练前期设置为大数值，训练后期设置为小数值。</li></ul></li><li>每次取数据都要设置<code>optimizer.zero_grad()</code>。</li><li>进行反向传播后，调用<code>optimizer.step()</code></li></ul><p>对dataset的每一次遍历就是一次训练过程，称为一个epoch。</p><h2 id="现有网络"><a href="#现有网络" class="headerlink" title="现有网络"></a>现有网络</h2><p>以<code>vgg16</code>为例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">vgg16_pretrained = torchvision.models.vgg16(VGG16_Weights.IMAGENET1K_FEATURES) <span class="hljs-comment"># 下载网络并赋予权重</span><br>vgg16.add_module(<span class="hljs-string">&quot;add_linear&quot;</span>, nn.Linear(<span class="hljs-number">1000</span>, <span class="hljs-number">10</span>)) <span class="hljs-comment"># 添加自己的module</span><br>vgg16.classifier[<span class="hljs-number">7</span>] = nn.Linear(<span class="hljs-number">4096</span>, <span class="hljs-number">10</span>) <span class="hljs-comment"># 修改module</span><br></code></pre></td></tr></table></figure><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><p>方式一：<code>torch.save(model_var_name, path)</code>：将模型结构以及参数保存为文件。</p><blockquote><p>注意path添加后缀，通常为.pth。</p></blockquote><p>方式二：<code>torch.save(model_var_name.state_dict(), path)</code>：仅保存模型参数（推荐）。</p><blockquote><p>注意path添加后缀，通常为.pkl。</p></blockquote><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p><code>torch.load(path)</code>：对应保存方式一。</p><p><code>model_var_name.load_state_dict()</code>：对应保存方式二。</p><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><h4 id="定义网络结构"><a href="#定义网络结构" class="headerlink" title="定义网络结构"></a>定义网络结构</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Network.py</span><br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyNetwork</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(MyNetwork, self).__init__()<br>        self.model_layers = nn.Sequential(<br>        nn.XXX(...)<br>        nn.XXX(...)<br>            ...<br>        )<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, <span class="hljs-built_in">input</span></span>):<br>        output = self.model_layers(<span class="hljs-built_in">input</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">input</span><br>    <br>    <br><span class="hljs-keyword">if</span>(__name__ == <span class="hljs-string">&quot;__main__&quot;</span>):<br>    mynetwork = MyNetwork()<br>    <span class="hljs-built_in">input</span> = xxx<br>    output = mynetwork(<span class="hljs-built_in">input</span>)<br>    <span class="hljs-built_in">print</span>(output.shape)<br></code></pre></td></tr></table></figure><h4 id="获取、读取数据集-训练"><a href="#获取、读取数据集-训练" class="headerlink" title="获取、读取数据集 | 训练"></a>获取、读取数据集 | 训练</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> datasets, transforms<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn, optim<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">from</span> Network <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 获取数据集并读取</span><br>train_dataset = datasets.CIFAR10(root=<span class="hljs-string">&quot;dataset_root&quot;</span>, train=<span class="hljs-literal">True</span>, transform=transforms.ToTensor(), download=<span class="hljs-literal">True</span>)<br>loader = DataLoader(train_dataset, shuffle=<span class="hljs-literal">True</span>, batch_size = <span class="hljs-number">64</span>, drop_last=<span class="hljs-literal">False</span>)<br>test_dataset = datasets.CIFAR10(root=<span class="hljs-string">&quot;dataset_root&quot;</span>, download=<span class="hljs-literal">True</span>, train=<span class="hljs-literal">False</span>, transform=transforms.ToTensor())<br>test_dataset_len = <span class="hljs-built_in">len</span>(test_dataset)<br>test_loader = DataLoader(test_dataset, shuffle=<span class="hljs-literal">True</span>, drop_last=<span class="hljs-literal">False</span>)<br>total_test_loss = <span class="hljs-number">0</span><br><span class="hljs-comment"># 实例化网络</span><br>network = MyNetwork()<br>loss = nn.CrossEntropyLoss()<br>optimizer = optim.SGD(network.parameters(), lr=<span class="hljs-number">0.01</span>)<br><span class="hljs-comment"># 定义训练参数</span><br>total_train_step = <span class="hljs-number">0</span><br>epoch = <span class="hljs-number">20</span><br>total_test_step = <span class="hljs-number">0</span><br><span class="hljs-comment"># 开始训练</span><br>mynetwork.train()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epoch):<br>    running_loss = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> imgs, targets <span class="hljs-keyword">in</span> loader:<br>    optimizer.zero_grad()<br>    output = network(imgs)<br>    loss_val = loss(output, targets) <br>    loss_val.backward()<br>    optimizer.step()<br>     total_train_step += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span>(total_train_step % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前训练次数：&#123;&#125; | 总训练次数：&#123;&#125; | 本次训练损失值：&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i, total_train_step, loss_val))<br></code></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 接上文</span><br>    mynetwork.<span class="hljs-built_in">eval</span>()<br>    correct_num = <span class="hljs-number">0</span><br><span class="hljs-keyword">with</span> torch.nograd():<br>   <span class="hljs-keyword">for</span> imgs, targets <span class="hljs-keyword">in</span> test_loader:<br>        output = mynetwork(imgs)<br>           correct_num += (targets == output.argmax(<span class="hljs-number">1</span>)).<span class="hljs-built_in">sum</span>()<br>            correct_num = correct_num.item()<br>        loss_val = loss(output, targets)<br>        total_test_loss += loss_val<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;整体损失率：&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(total_test_loss))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;整体正确率：&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">float</span>(correct_num/test_dataset_len)))<br>    torch.save(mynetwork, <span class="hljs-string">&quot;network&#123;&#125;.pth&quot;</span>.<span class="hljs-built_in">format</span>(i))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>人工智能</tag>
      
      <tag>Python</tag>
      
      <tag>Pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字化皮影戏交互系统开发日志——沙盘模块①</title>
    <link href="/2024/01/26/%E6%95%B0%E5%AD%97%E5%8C%96%E7%9A%AE%E5%BD%B1%E6%88%8F%E4%BA%A4%E4%BA%92%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%E2%80%94%E2%80%94%E6%B2%99%E7%9B%98%E6%A8%A1%E5%9D%97%E2%91%A0/"/>
    <url>/2024/01/26/%E6%95%B0%E5%AD%97%E5%8C%96%E7%9A%AE%E5%BD%B1%E6%88%8F%E4%BA%A4%E4%BA%92%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%E2%80%94%E2%80%94%E6%B2%99%E7%9B%98%E6%A8%A1%E5%9D%97%E2%91%A0/</url>
    
    <content type="html"><![CDATA[<p>从零开始的一次尝试。<br>    <span id="more"></span></p><h2 id="初期策划"><a href="#初期策划" class="headerlink" title="初期策划"></a>初期策划</h2><p>既然名为“数字皮影戏科普交互系统”，首要需求便是在程序内复原实物皮影戏，包括视觉观感、操作方式、音效氛围、演绎内容等。</p><p>策划期间，需要着重考虑可行性。笔者作为技术人员，将技术可行性作为策划期间的首要考虑因素。</p><p><img src="https://yoi-note.oss-cn-chengdu.aliyuncs.com/Image/202401261814028.png" alt="image-20240126181415934"></p><h3 id="基本可行性"><a href="#基本可行性" class="headerlink" title="基本可行性"></a>基本可行性</h3><p>上面是一张实物皮影戏的视频截图。可以观察到，实物皮影戏在视觉上与传统2D平面游戏的区别在于：</p><ul><li>“远虚近实”：元素离幕布越远，色调越偏向黑色，并且越来越淡，同时整体越来越大。</li><li>位于幕后：所有元素在实物皮影戏中均位于幕布之后，通过投影在另一端呈现。</li></ul><p>“远虚近实”效果涉及到Sprite的两方面：大小与颜色。前者（Sprite的大小随距离变化）只需编写脚本动态修改Sprite的localScale即可。后者（同时修改材质的颜色与透明度）同样可以使用脚本实现。但为了提前学习图形学知识，笔者这里选择编写Shader。</p><p><img src="https://yoi-note.oss-cn-chengdu.aliyuncs.com/Image/202401261822658.png" alt="image-20240126182248623"></p><p>上图展示了Shader的编写思路。材质附着在影人上时，通过_WorldSpaceCameraPos可得到L2。保持L1不变（一般是实物皮影戏里的摄像机也不会移动过），就可计算得到L3。把L3作为变量加入Shader的frag函数中，即可让材质片元随L3的变化而变化。因此，技术上可行。</p><h3 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h3><p>最主要的视觉视效复刻是完全可行的。接下来考虑程序的整体框架。</p><p><img src="https://yoi-note.oss-cn-chengdu.aliyuncs.com/Image/202401261826536.png" alt="image-20240126182620479"></p><h4 id="沙盘模块"><a href="#沙盘模块" class="headerlink" title="沙盘模块"></a>沙盘模块</h4><p>对于影人，各个部件就是骨骼，部件之间的转轴就是关节。现实中表演者是用几根棍子拖动影人的主要关节来使其移动的，游戏里我们可以用鼠标拖动模拟棍子拖动。对于没有棍子控制的部位，一般使用重力+惯性的方式使其移动。在Unity里，这意味着它们要附着刚体与碰撞体组件。</p><p>如果先不考虑影人的自动移动与表演，单纯把影人作为一个2D布娃娃来看的话，只需要用铰链关节把各部位连接起来就可以了。技术可行。此外，2D布娃娃也可以作为系统的一部分，让用户拖着这个布娃娃在空白的场景里自由的玩耍。这就是沙盘模块。</p><h4 id="戏剧播放模块"><a href="#戏剧播放模块" class="headerlink" title="戏剧播放模块"></a>戏剧播放模块</h4><p>既然是复原实物皮影戏，那程序肯定得能播放经典的皮影戏剧。直接放视频未免显得太敷衍，我们要搭建一套完善的皮影戏剧播放模块。在实现了沙盘模块的基础上，我们有两个选择：</p><ul><li>不沿用2D布娃娃系统，改用2D骨骼动画。这种方式比较困难，因为皮影剧目往往持续十分钟以上，如果用K帧的方式做动画的话工作量太大。</li><li>沿用2D布娃娃系统，想办法借此制作动画。</li></ul><p>一番权衡利弊，还是在沙盘模式的基础上制作剧目动画比较好。而且如果给沙盘模式加入录制功能的话，玩家也可以自己录剧目自己看，也不失为一种乐趣。</p><p>就像视频是由一帧帧图片构成的一样，数字皮影剧目里，“一帧”是由场景内众多元素的位置信息构成的。只要每隔一段极短的时间，把时间信息与当前帧所有元素的位置信息写入文件，就可以完成“剧目”的记录。播放时，读取文件即可播放剧目。</p><h4 id="图鉴模块"><a href="#图鉴模块" class="headerlink" title="图鉴模块"></a>图鉴模块</h4><p>作为科普应用，我们的系统自然也是得有图鉴模块的。图鉴模块就比较简单，一个滑动窗口+若干UI元素就完事了。当然，要做的花哨的话，也可以模仿老滚5的加载界面，点一个UI单元，右边就会呈现它的模型。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>沙盘模块做完以后，做其他模块都会比较方便，所以笔者首先进行沙盘模块的编码。</p><h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><h4 id="拖拽与铰链关节的配合"><a href="#拖拽与铰链关节的配合" class="headerlink" title="拖拽与铰链关节的配合"></a>拖拽与铰链关节的配合</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnMouseDown</span>()</span><br>&#123;<br>    <span class="hljs-comment">//将物体坐标转换为屏幕坐标，获取Z轴长度</span><br>    _screenPoint = Camera.main.WorldToScreenPoint(gameObject.transform.position);<br>    <span class="hljs-comment">//计算物体中心点和鼠标触发点坐标得差值</span><br>    _offset = gameObject.transform.position - Camera.main.ScreenToWorldPoint(<span class="hljs-keyword">new</span> Vector3(Input.mousePosition.x, Input.mousePosition.y, _screenPoint.z));<br>&#125;<br></code></pre></td></tr></table></figure><p>OnMouseDrag()事件函数本质上是改变Transform的position，并不是对刚体产生影响，而铰链关节的相互作用是基于刚体的。因此，使用OnMouseDrag()编写的拖拽功能，在生效时，整个影人都是静止的，完全不存在惯性。</p><p>可能是笔者才疏学浅，到目前为止没听说过基于刚体的拖拽实现。因此，我们要在保留OnMouseDrag拖拽的同时，对刚体进行处理。</p><p>如果按照现实物理的思路，应当为对象手动添加“与拖拽相关联的惯性”。在OnMouseDrag()中记录鼠标移动增量，并以此作为速度。通过Update+Lerp实现对象Rigidbody.velocity不断向鼠标移动速度逼近，以此模仿惯性。然而，这种方式实现起来还是比较困难，同时也比较耗性能。</p><p>惯性在含有铰链关节的对象上最显著的表现是：对象物体向一端加速移动时，铰链连接着的另一物体会呈现“向反方向移动”的表现。那么，是不是只要在拖动父物体时，给子物体施加反方向速度，就能模拟惯性呢？</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnMouseDrag</span>()</span>&#123;<br>    Vector3 _prevPosition = _curPosition;<span class="hljs-comment">//记录此前鼠标位置</span><br>    _curScreenPoint = <span class="hljs-keyword">new</span> Vector3(Input.mousePosition.x, Input.mousePosition.y, _screenPoint.z);<br>_curPosition = Camera.main.ScreenToWorldPoint(_curScreenPoint) + _offset;<span class="hljs-comment">//坐标系转换</span><br>_velocity = InertiiaPara*(_curPosition - _prevPosition);<span class="hljs-comment">//计算速度，其中InertiiaPara表示速度系数，越大，对反方向施加的速度就越大</span><br>transform.position = _curPosition;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果非常好。</p><h4 id="多相机混合"><a href="#多相机混合" class="headerlink" title="多相机混合"></a>多相机混合</h4><p>第一次用著名Unity插件Top-Down Engine时，单独UI Camera渲染UI的实现方式深深震撼了Unity初学者的心。不管怎么说，这个项目笔者都要用上这种方式。</p><p>新建一个Camera，把Audio Listener去掉（<strong>场景内通常只存在一个Audio Listener，一般附着在Main Camera上</strong>），把它的投影方式设置为正交（因为UI不需要透视）。</p><p>注意，Clear Flags要设置为Depth Only。这里的Depth指的是相机的Depth，Depth越高的相机渲染次序越靠后。即便UI位于一大堆主相机看着的Opaque物体之后，只要UI Camera的Depth大于Main Camera，UI就能好好显示。网上有个设置UICamera的教材让把Clear Flag设置为Dont Clear，属实误人子弟。</p><p>Culling Mask设置为UI，这样UI Camera就不会渲染其他不小心跑进来的东西。</p><h4 id="代码控制Scale"><a href="#代码控制Scale" class="headerlink" title="代码控制Scale"></a>代码控制Scale</h4><p>对于2D Sprite，调整Scale时，变化的基点是Pivot。例如，Pivot位于中心的正方形，Scale等比例增大时，其四条边均匀远离中心。Pivot位于下边中点的正方形，Scale等比例增大时，下边的世界坐标（这么说其实不严谨，理解就行）不会发生变化。</p><p>通过改变Sprite的Pivot（在Sprite Editor中进行），可以避免例如位于屏幕边缘的Sprite调整Scale后超出屏幕范围的情况。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数字皮影戏系统</tag>
      
      <tag>开发日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
