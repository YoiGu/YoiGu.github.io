

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/tagIcon.png">
  <link rel="icon" href="/img/tagIcon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Yoi">
  <meta name="keywords" content="">
  
    <meta name="description" content="屏幕后处理 MonoBehavior有这样一个函数：OnRenderImage(RenderTexture src, RenderTexture dest)，在每帧渲染完成后调用。其中，第一个参数为当前完成渲染的图像，第二个参数为最终输出到屏幕上的图像。该函数默认在完成所有步透明、半透明物体的渲染后调用。如果想更改该函数的生效次序，使其在不透明物体渲染完毕后，半透明物体渲染前执行，则为其添加[I">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity Shader学习笔记（四） - 后处理与NPR">
<meta property="og:url" content="http://example.com/2025/02/10/Unity-Shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89-%E5%90%8E%E5%A4%84%E7%90%86%E4%B8%8ENPR/index.html">
<meta property="og:site_name" content="Yoi&#39;s Home">
<meta property="og:description" content="屏幕后处理 MonoBehavior有这样一个函数：OnRenderImage(RenderTexture src, RenderTexture dest)，在每帧渲染完成后调用。其中，第一个参数为当前完成渲染的图像，第二个参数为最终输出到屏幕上的图像。该函数默认在完成所有步透明、半透明物体的渲染后调用。如果想更改该函数的生效次序，使其在不透明物体渲染完毕后，半透明物体渲染前执行，则为其添加[I">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yoi-note.oss-cn-chengdu.aliyuncs.com/Image/202502031158050.png">
<meta property="og:image" content="https://yoi-note.oss-cn-chengdu.aliyuncs.com/Image/202502071120564.png">
<meta property="og:image" content="https://yoi-note.oss-cn-chengdu.aliyuncs.com/Image/202502081036540.png">
<meta property="article:published_time" content="2025-02-10T08:36:33.000Z">
<meta property="article:modified_time" content="2025-02-10T08:37:20.293Z">
<meta property="article:author" content="Yoi">
<meta property="article:tag" content="Unity">
<meta property="article:tag" content="Shader">
<meta property="article:tag" content="技术美术">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://yoi-note.oss-cn-chengdu.aliyuncs.com/Image/202502031158050.png">
  
  
  
  <title>Unity Shader学习笔记（四） - 后处理与NPR - Yoi&#39;s Home</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.16.2/katex.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>攸一的文书档案</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://yoi-note.oss-cn-chengdu.aliyuncs.com/Image/202401261945400.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Unity Shader学习笔记（四） - 后处理与NPR"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-02-10 16:36" pubdate>
          2025年2月10日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5.3k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          44 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Unity Shader学习笔记（四） - 后处理与NPR</h1>
            
              <p id="updated-time" class="note note-info" style="">
                
                  
                    本文最后更新于 2025年2月10日 下午
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h2 id="屏幕后处理"><a class="markdownIt-Anchor" href="#屏幕后处理"></a> 屏幕后处理</h2>
<p><code>MonoBehavior</code>有这样一个函数：<code>OnRenderImage(RenderTexture src, RenderTexture dest)</code>，在每帧渲染完成后调用。其中，第一个参数为当前完成渲染的图像，第二个参数为最终输出到屏幕上的图像。该函数默认在完成所有步透明、半透明物体的渲染后调用。如果想更改该函数的生效次序，使其在不透明物体渲染完毕后，半透明物体渲染前执行，则为其添加<code>[ImageEffectOpaque]</code>属性。</p>
<p><code>Graphics.Blit(Texture src, RenderTexture dest, Material mat, int pass = -1)</code>用于将src纹理作为名为“_MainTex”的材质属性传递给mat对应的Shader。经过mat处理后，图像被输出到dest上。pass变量用于指定处理图像的Shader Pass序号，若为-1则从上到下执行所有Pass。</p>
<p>通常，我们完成后处理材质mat的编写后，直接在<code>OnRenderImage</code>中调用<code>Graphics.Blit(src, dest, mat)</code>即可。但有些情况下，我们需要分步对图像进行处理。此时，我们需要调用<code>RenderTexture.GetTemporary(int RTWidth, int RTHeight, 0)</code>来获取一张临时的RenderTexture作为Buffer，然后调用多次Blit函数。完成Blit后，<strong>记得调用<code>RenderTexture.ReleaseTemporary(RenderTexture)</code>释放内存</strong>。</p>
<p>屏幕后处理脚本需要绑定在相机上。</p>
<p>屏幕后处理对设备条件有所限制。为了检查设备是否满足条件，使用下列代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">CheckSupport</span>()</span>&#123;<br>    <span class="hljs-keyword">if</span>(SystemInfo.supportsImageEffects == <span class="hljs-literal">false</span> || SystemInfo.supportsRenderTextures == <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们既可以直接从Shader创建后处理Mat并拖拽到脚本的Inspector，也可以根据Shader动态创建后处理Mat实例。代码如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">protected</span> Material <span class="hljs-title">CheckShaderAndCreateMaterial</span>(<span class="hljs-params">Shader shader, Material material</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(shader == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span>(!shader.isSupported) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span>(material &amp;&amp; material.shader == shader)&#123;<br>        <span class="hljs-keyword">return</span> material;<br>    &#125;<br>    material = <span class="hljs-keyword">new</span> Material(shader);<br>    material.hideFlags = HideFlags.DontSave; <span class="hljs-comment">// 由于此函数在Edit模式中也会执行，而我们不希望这个材质实例被保存在Scene中，所以设置下hideFlags</span><br>    <span class="hljs-keyword">if</span>(material) <span class="hljs-keyword">return</span> material;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="基本调色"><a class="markdownIt-Anchor" href="#基本调色"></a> 基本调色</h3>
<p>在MB脚本中定义变量<code>brightness</code>、<code>saturation</code>、<code>contrast</code>，可用<code>Range</code>属性修饰以控制范围。</p>
<p>在<code>OnRenderImage</code>中，使用<code>material.SetFloat</code>函数设置属性，并调用<code>Graphics.Blit</code>进行后处理。</p>
<p>在Shader中，定义同名的三个属性。对于后处理材质，起手式如下：</p>
<p><code>ZTest Always Cull Off ZWrite Off</code></p>
<p><code>Fallback Off</code></p>
<p>因为屏幕后处理本质上是绘制覆盖屏幕的面片，它需要始终通过深度测试，且不进行深度写入。</p>
<ul>
<li>亮度是对最终颜色强度的直接处理，直接<code>color * _brightness</code>即可。</li>
<li>饱和度是灰色与纯色之间的lerp因子。</li>
<li>对比度是图像亮部与暗部的比值。</li>
</ul>
<p>FS如下：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs glsl">fixed4 frag(v2f i) : SV_Target&#123;<br>    fixed4 renderTex = tex2D(_MainTex, i.uv);<br>    <span class="hljs-comment">// 亮度</span><br>    fixed3 finalColor = renderTex.rgb * _Brightness;<br>    <span class="hljs-comment">// 饱和度</span><br>    fixed luminance = <span class="hljs-built_in">dot</span>(renderTex.rgb, fixed3(<span class="hljs-number">0.2125</span>, <span class="hljs-number">0.7154</span>, <span class="hljs-number">0.0721</span>)); <span class="hljs-comment">// 将此像素的颜色转变为灰度值，这里的参数根据人眼对三原色的敏感度不同而定</span><br>    fixed3 luminanceColor = fixed3(luminance, luminance, luminance); <span class="hljs-comment">// 灰度值的rgb分量数值必然一致</span><br>    finalColor = lerp(luminanceColor, finalColor, _Saturation); <span class="hljs-comment">// 进行lerp</span><br>    <span class="hljs-comment">// 对比度</span><br>    finalColor = (finalColor - <span class="hljs-number">0.5</span>) * _Contrast + <span class="hljs-number">0.5</span>; <span class="hljs-comment">// 扩大/缩小当前颜色与中性灰(0.5,0.5,0.5)的差距</span><br>    <span class="hljs-keyword">return</span> fixed4(finalColor, renderTex.a);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="边缘检测"><a class="markdownIt-Anchor" href="#边缘检测"></a> 边缘检测</h3>
<p>通过卷积完成。</p>
<p>常见的边缘检测算子如下：</p>
<p><img src="https://yoi-note.oss-cn-chengdu.aliyuncs.com/Image/202502031158050.png" srcset="/img/loading.gif" lazyload alt="image-20250203115809859" /></p>
<p><code>OnRenderImage</code>函数同样是先设置材质属性，然后通过<code>Graphics.Blit</code>进行后处理。</p>
<p>v2f中，需要将原本的<code>half2 uv</code>改为<code>half2 uv[9]</code></p>
<p>VS中，使用<code>_MainTex_TexelSize.xy</code>获取纹素尺寸，并按顺序获取主像素周围的8个像素的纹理坐标：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs glsl">v2f vert(appdata_img v)&#123;<br>    v2f o;<br>    o.pos = mul(UNITY_MATRIX_MVP, v.vertex);<br>    half2 uv = v.texcoord;<br>    o.uv[<span class="hljs-number">0</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">// 下略</span><br>    <span class="hljs-keyword">return</span> o;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>FS中，将颜色灰度化，并将灰度化后的颜色使用Sobel算子进行卷积：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs glsl">fixed luminance(fixed4 color)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0.2125</span> * color.r + <span class="hljs-number">0.7154</span> * color.g + <span class="hljs-number">0.0721</span> * color.b;<br>&#125;<br>half Sobel(v2f i)&#123;<br>    <span class="hljs-keyword">const</span> half Gx[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;; <span class="hljs-comment">// Sobel X算子</span><br>    <span class="hljs-keyword">const</span> half Gy[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;; <span class="hljs-comment">// Sobel Y算子</span><br>    half texColor;<br>    half edgeX = <span class="hljs-number">0</span>;<br>    half edgeY = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> it=<span class="hljs-number">0</span>;it&lt;<span class="hljs-number">9</span>;it++)&#123; <span class="hljs-comment">// 每个像素均会调用一次该函数，每次调用进行一次卷积</span><br>        texColor = luminance(tex2D(_MainTex,i.uv[it])); <span class="hljs-comment">// 颜色灰度化，便于提取边缘</span><br>        edgeX += texColor * Gx[it];<br>        edgeY += texColor * Gy[it];<br>    &#125;<br>    half edge = <span class="hljs-number">1</span>- <span class="hljs-built_in">abs</span>(edgeX) - <span class="hljs-built_in">abs</span>(edgeY); <span class="hljs-comment">// 最终的edge值越小，越有可能是边缘</span><br>    <span class="hljs-keyword">return</span> edge;<br>&#125;<br>fixed4 fragSobel(v2f i) : SV_Target&#123;<br>    half edge = Sobel(i);<br>    fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[<span class="hljs-number">4</span>], edge));<br>    fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);<br>    <span class="hljs-keyword">return</span> lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly); <span class="hljs-comment">// 用lerp代替if，避免分支语句</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>记得<code>Fallback Off</code>。</p>
<h3 id="高斯模糊"><a class="markdownIt-Anchor" href="#高斯模糊"></a> 高斯模糊</h3>
<p>二维高斯卷积核会导致迭代次数过多。我们可以将其拆分为两个一维卷积核，分别卷积水平和垂直方向。首先，在第一个Pass里进行水平方向卷积，将结果存储在Buffer中，然后在第二个Pass里使用上一步的结果进行垂直方向卷积。</p>
<p>高斯模糊不需要原图分辨率那么高的精度，所以可以对图像进行缩放后再模糊，可以大大减少运算量：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span>(<span class="hljs-params">RenderTexture src, RenderTexture dest</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(material)&#123;<br>        <span class="hljs-built_in">int</span> rtW = src.width/downSample;<br>        <span class="hljs-built_in">int</span> rtH = src.height/downSample;<br>        RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, <span class="hljs-number">0</span>);<br>        buffer0.filterMode = FilterMode.Bilinear;<br>        Graphics.Blit(src, buffer0, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;iterations;i++)&#123;<br>            material.setFloat(<span class="hljs-string">&quot;_BlurSize&quot;</span>,<span class="hljs-number">1.0f</span>+i*blurSpeed);<br>            RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="hljs-number">0</span>);<br>            Graphics.Blit(buffer0, buffer1, material, <span class="hljs-number">0</span>);<br>            RenderTexture.ReleaseTemporary(buffer0);<br>            buffer0 = buffer1;<br>            buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="hljs-number">0</span>);<br>            Graphics.Blit(buffer0, buffer1, material, <span class="hljs-number">1</span>);<br>            buffer0 = buffer1;<br>        &#125;<br>        Graphics.Blit(buffer0, dest);<br>        RenderTexture.ReleaseTemporary(buffer0);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        Graphics.Blit(src, dest);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>关键FS代码：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs glsl">fixed4 fragBlur(v2f i) : SV_Target&#123;<br>    <span class="hljs-type">float</span> weight[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">0.4026</span>, <span class="hljs-number">0.2442</span>, <span class="hljs-number">0.0545</span>&#125;; <span class="hljs-comment">//实际上卷积核有五个元素，但它们以0.0545为轴对齐，这是正态分布的性质导致的</span><br>    fixed3 sum = tex2D(_MainTex, i.uv[<span class="hljs-number">0</span>]).rgb * weight[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 中间的像素</span><br>    <span class="hljs-comment">// 两端的像素</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> it = <span class="hljs-number">1</span>; it&lt;<span class="hljs-number">3</span>; it++)&#123;<br>        sum += tex2D(_MainTex, i.uv[it*<span class="hljs-number">2</span><span class="hljs-number">-1</span>]).rgb * weight[it];<br>        sum += tex2D(_MainTex, i.uv[<span class="hljs-number">2</span>*it]).rgb * weight[it];<br>    &#125;<br>    <span class="hljs-keyword">return</span> fixed4(sum, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="泛光"><a class="markdownIt-Anchor" href="#泛光"></a> 泛光</h3>
<p>泛光的步骤如下：</p>
<ol>
<li>首先，根据一个阈值提取出图像的较亮区域，将其存储在一张RT中</li>
<li>然后，对此RT进行高斯模糊</li>
<li>最后，将模糊的结果与原图像混合</li>
</ol>
<p><code>OnRenderImage</code>如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span>(<span class="hljs-params">RenderTexture src, RenderTexture dest</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(material != <span class="hljs-literal">null</span>)&#123;\<br>        <span class="hljs-comment">// 1. 根据阈值采集图像亮度较高的区域(Pass 0)</span><br>        material.setFloat(<span class="hljs-string">&quot;_LuminanceThreshold&quot;</span>, luminanceThreshold);<br>        <span class="hljs-built_in">int</span> rtW = src.width / downSample;<br>        <span class="hljs-built_in">int</span> rtH = src.height / downSample;<br>        RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, <span class="hljs-number">0</span>);<br>        buffer0.filterMode = FilterMode.Bilinear;<br>        Graphics.Blit(src, buffer0, material, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 2. 进行高斯模糊</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;iterations; i++)&#123;<br>            material.setFloat(<span class="hljs-string">&quot;_BlurSize&quot;</span>, <span class="hljs-number">1.0f</span> + i*blurSpread);<br>            RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="hljs-number">0</span>);<br>            <span class="hljs-comment">// 2.1 水平方向模糊(Pass 1)</span><br>            Graphics.Blit(buffer0, buffer1, material, <span class="hljs-number">1</span>);<br>            RenderTexture.ReleaseTemporary(buffer0);<br>            buffer0 = buffer1;<br>            buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="hljs-number">0</span>);<br>            <span class="hljs-comment">// 2.2 竖直方向模糊(Pass 2)</span><br>            Graphics.Blit(buffer0, buffer1, material, <span class="hljs-number">2</span>);<br>            RenderTexture.ReleaseTemporary(buffer0);<br>            buffer0 = buffer1;<br>        &#125;<br>        material.setTexture(<span class="hljs-string">&quot;_Bloom&quot;</span>, buffer0);<br>        <span class="hljs-comment">// 3. 将模糊后的高亮区域与原图像混合</span><br>        Graphics.Blit(src, dest, material,<span class="hljs-number">3</span>);<br>        RenderTexture.ReleaseTemporary(buffer0);<br>    &#125; <span class="hljs-keyword">else</span> Graphics.Blit(src,dest);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Shader代码略。</p>
<h3 id="运动模糊"><a class="markdownIt-Anchor" href="#运动模糊"></a> 运动模糊</h3>
<p>常见的运动模糊实现策略有累计缓存（Accumulation Buffer）和速度缓存（Velocity Buffer）。前者取多帧连续图像的平均值作为输出，但性能消耗非常大；后者存储各像素当前的运动速度，依次决定模糊的方向和大小。这里我们使用方法一。</p>
<p><code>OnRenderImage</code>如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span>(<span class="hljs-params">RenderTexture src, RenderTexture dest</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(material != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(accumulationTexture == <span class="hljs-literal">null</span> || accumulationTexture.width != src.width || accumulationTexture.height != src.height)&#123;<br>            DestroyImmediate(accumulationTexture);<br>            accumulationTexture = <span class="hljs-keyword">new</span> RenderTexture(sec.width, src.height, <span class="hljs-number">0</span>);<br>            accumulationTexture.hideFlags = HideFlags.HideAndDontSave;<br>            Graphics.Blit(src, accumulationTexture);<br>        &#125;<br>        accumulationTexture.MarkRestoreExpected(); <span class="hljs-comment">// 多帧连续复用同一RT时，调用此方法，以执行“恢复”操作，本质上是告诉Unity，下一帧无需清除此RT内的数据</span><br>        material.SetFloat(<span class="hljs-string">&quot;_BlurAmount&quot;</span>, <span class="hljs-number">1.0f</span> - blurAmount);<br>        Graphics.Blit(src, accumulationTexture, material); <span class="hljs-comment">// 将当前屏幕图像叠加到accumulationTexture中</span><br>        Graphics.Blit(accumulationTexture, dest); <span class="hljs-comment">// 输出</span><br>    &#125;<span class="hljs-keyword">else</span> Graphics.Blit(src, dest);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Shader的两个Pass非常简单，第一个Pass设置<code>ColorMask RGB</code>，第二个Pass设置<code>ColorMask A</code>。之所以将RGB和A通道分开是为了A通道由<code>_BlurAmount</code>控制，表示模糊的强度。</p>
<h2 id="使用深度-法线纹理"><a class="markdownIt-Anchor" href="#使用深度-法线纹理"></a> 使用深度、法线纹理</h2>
<p>对于某些高级的屏幕后处理效果，仅获取屏幕颜色信息是不够的，还需要像G-Buffer一样，获取屏幕空间的深度和法线信息。</p>
<p>对于深度纹理：</p>
<p>使用延迟渲染管线时，深度纹理存储在G-Buffer中，自然可以直接访问。使用前向渲染管线时，需要用一个单独的Pass渲染得到。在Unity中，只有RenderType为“Background”、“Geometry”和“AlphaTest”的物体可以被渲染到深度、法线纹理。</p>
<p>如果只需要深度纹理，那Unity会直接使用ShadowCaster Pass（一般存在于Fallback中）来得到深度纹理。</p>
<p>如果需要深度+法线纹理，Unity会创建一张分辨率与屏幕相同，格式为ARGB32的纹理。其中，观察空间下的法线被编码进R、G通道，深度信息编码入B和A通道。</p>
<p>通过设置Camera组件的<code>depthTextureMode</code>属性为<code>DepthTextureMode.Depth</code>，Unity就会声明全局Shader属性<code>_CameraDepthTexture</code>，内部存储有深度纹理。设置为<code>DepthTextureMode.DepthNormals</code>，则会声明<code>_CameraDepthNormalsTexture</code>，存储有深度+法线纹理。<code>DepthTextureMode</code>是Flag，可以通过或（“|”）的形式同时声明多种模式。</p>
<p>采样深度纹理时，我们通过<code>SAMPLE_DEPTH_TEXTURE</code>宏进行，以避免平台不同导致的差错。也可以通过<code>SAMPLE_DEPTH_TEXTURE_PROJ(_CameraDepthTexture, UNITY_PROJ_COORD(i.scrPos))</code>采样，其中<code>scrPos</code>为使用<code>ComputeScreenPos</code>函数计算得到的屏幕空间坐标。</p>
<p>通过上述方式采样得到的深度值是非线性变化的，但我们实际需要的是线性变化的深度值。为此，我们需要使用<code>LinearEyeDepth</code>或<code>Linear01Depth</code>对采样值进行转换。前者返回取值范围在<code>[Near, Far]</code>的深度值，后者返回<code>[0,1]</code>范围内的深度值。</p>
<p>若需要采样<code>_CameraDepthNormalsTexture</code>采样深度及法线，则使用下面的函数：</p>
<p><code>void DecodeDepthNormal(float4 enc, out float depth, out float3 normal)</code>，其内部调用了<code>DecodeFloatRG</code>和<code>DecodeViewNormalStereo</code>方法。</p>
<h3 id="优化运动模糊"><a class="markdownIt-Anchor" href="#优化运动模糊"></a> 优化运动模糊</h3>
<p>前面提到，更优的运动模糊实现方式是使用速度映射图，即存储每个像素的速度。我们可以通过深度图重建每个像素的世界坐标，然后将当前帧的像素世界坐标通过前一帧的VP矩阵进行变换，得到此位置在前一帧的NDC坐标。随后，计算前一帧和当前帧的位置差，即可生成该像素的速度。步骤如下：</p>
<ol>
<li>首先，在MB脚本中定义<code>Matrix4x4</code>变量<code>previousViewProjectionMatrix</code>，用于保存上一帧的VP矩阵。</li>
<li>在MB脚本中设置<code>camera.depthTextureMode |= DepthTextureMode.Depth</code>，以开启深度图渲染</li>
<li><code>OnRenderImage</code>如下：</li>
</ol>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span>(<span class="hljs-params">RenderTexture src, RenderTexture dest</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(material!=<span class="hljs-literal">null</span>)&#123;<br>        material.SetFloat(<span class="hljs-string">&quot;_BlurSize&quot;</span>, blurSize);<br>        material.SetMatrix(<span class="hljs-string">&quot;_PreviousViewProjectionMatrix&quot;</span>, previousViewProjectionMatrix);<br>        Matrix4x4 currentrViewProjectionMatrix = camera.projectionMatrix * camera.worldToCameraMatrix;<br>        Matrix4x4 currentViewProjectionInverseMatrix = currentViewProjectionMatrix.inverse;<br>        material.SetMatrix(<span class="hljs-string">&quot;_CurrentViewProjectionInverseMatrix, currentViewProjectionInverseMatrix&quot;</span>);<br>        previousViewProjectionMatrix = currentViewProjectionMatrix;<br>        Graphics.Blit(src, dest, material);<br>    &#125; <span class="hljs-keyword">else</span> Graphics.Blit(src,dest);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中，当前VP矩阵的逆矩阵用于将当前片段还原到世界坐标；上一帧的VP矩阵用于将当前片段的世界坐标变换到上一帧的NDC坐标。</p>
<ol start="4">
<li>Shader如下：</li>
</ol>
<p>VS：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs glsl">struct v2f&#123;<br>    float4 pos : SV_POSITION;<br>    half2 uv : TEXCOORD0;<br>    half2 uv_depth : TEXCOORD1;<br>&#125;<br>v2f vert(appdata_img v)&#123;<br>    v2f o;<br>    o.pos = mul(UNITY_MATRIX_MVP, v.vertex);<br>    o.uv = v.texcoord;<br>    o.uv_depth = v.texcoord;<br>    <span class="hljs-meta">#if UNITY_UV_STARTS_AT_TOP</span><br>    	o.uv_depth.y = <span class="hljs-number">1</span>-o.uv_depths.y; <span class="hljs-comment">// 处理平台差异导致的纹理上下翻转问题</span><br>    <span class="hljs-meta">#endif</span><br>    <span class="hljs-keyword">return</span> o;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>FS：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs glsl">fixed4 frag(v2f i) : SV_Target&#123;<br>    <span class="hljs-type">float</span> d = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth); <span class="hljs-comment">// 当前片段深度值</span><br>    float4 H = float4(i.uv.x*<span class="hljs-number">2</span><span class="hljs-number">-1</span>, i.uv.y*<span class="hljs-number">2</span><span class="hljs-number">-1</span>, d*<span class="hljs-number">2</span><span class="hljs-number">-1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 当前片段NDC坐标</span><br>    float4 D = mul(_CurrentViewProjectionInverseMatrix, H);  <span class="hljs-comment">// 当前片段</span><br>    float4 worldPos = D/D.w; <span class="hljs-comment">// 当前片段世界坐标</span><br>    float4 currentPos = H; <span class="hljs-comment">// 我们后续将使用NDC坐标计算像素速度</span><br>    float4 previousPos = mul(_PreviousViewProjectionMatrix, worldPos); <br>    previousPos /= previousPos.w; <span class="hljs-comment">// 当前片段在上一帧的NDC坐标</span><br>    float2 velocity = (currentPos.xy - previousPos.xy)/<span class="hljs-number">2.0</span>f; <span class="hljs-comment">// 根据前后两帧的NDC坐标位置差得到速度</span><br>    float2 uv = i.uv;<br>    float4 c = tex2D(_MainTex, uv); <span class="hljs-comment">// 当前片段的颜色值</span><br>    uv += velocity * _BlurSize; <span class="hljs-comment">// 根据速度偏移UV</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> it = <span class="hljs-number">1</span>; it&lt;<span class="hljs-number">3</span>; it++, uv+=velocity*_BlurSize)&#123;<br>        float4 currentColor = tex2D(_MainTex, uv); <span class="hljs-comment">// 从速度方向进行采样</span><br>        c+=currentColor;<br>    &#125;<br>    c/=<span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">return</span> fixed4(c.rgb,<span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>记得关闭<code>Fallback</code>。</p>
<h3 id="全局雾效"><a class="markdownIt-Anchor" href="#全局雾效"></a> 全局雾效</h3>
<h4 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h4>
<p>在Unity中，可以通过<code>#pragma multi_compile_fog</code>指令、<code>UNITY_FOG-COORDS</code>、<code>UNITY_TRANSFER_FOG</code>、<code>UNITY_APPLY_FOG</code>等内置宏开启雾效。然而，使用这种方法无法对雾效进行精确的控制。</p>
<p>屏幕后处理雾效是一种灵活的全局雾效方案，其关键点在于通过深度纹理重计算出各像素的世界坐标。在上一节运动模糊中，我们使用下列代码重计算世界坐标：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">float</span> d = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth); <span class="hljs-comment">// 当前片段深度值</span><br>float4 H = float4(i.uv.x*<span class="hljs-number">2</span><span class="hljs-number">-1</span>, i.uv.y*<span class="hljs-number">2</span><span class="hljs-number">-1</span>, d*<span class="hljs-number">2</span><span class="hljs-number">-1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 当前片段NDC坐标</span><br>float4 D = mul(_CurrentViewProjectionInverseMatrix, H);  <span class="hljs-comment">// 当前片段</span><br>float4 worldPos = D/D.w; <span class="hljs-comment">// 当前片段世界坐标</span><br></code></pre></td></tr></table></figure>
<p>然而，对此方法来说，矩阵变换是不可避免的，而这对性能要求较高。在本节，我们将学习基于射线插值的重建世界坐标方法。</p>
<p>在世界坐标系中，一个顶点的位置可以通过另一个顶点坐标+一个偏移量得到。因此，我们只需要知道摄像机的位置，并得到像素相对于相机在世界空间下的偏移量，就能得到像素的世界坐标。代码如下：</p>
<p><code>float4 worldPos = _WorldSpaceCameraPos + linearDepth * interpolatedRay;</code></p>
<p>其中，<code>_WorldSpaceCameraPos</code>为世界空间相机位置，<code>linearDepth</code>为深度纹理采样、转换得到的线性深度值，<code>interpolatedRay</code>为VS输出并插值得到的射线，它包含了像素到摄像机的方向和距离信息。</p>
<p>下面详细阐述原理。</p>
<p><img src="https://yoi-note.oss-cn-chengdu.aliyuncs.com/Image/202502071120564.png" srcset="/img/loading.gif" lazyload alt="image-20250207112026368" /></p>
<p>如图，图13.6中的矩形是摄像机近平面，TL、TR、BL和BR是近平面的四个角。通过下列公式，我们可以得到TL、TR、BL、BR点在相机坐标系下的位置：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mi>L</mi><mo>=</mo><mi>c</mi><mi>a</mi><mi>m</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>f</mi><mi>o</mi><mi>r</mi><mi>w</mi><mi>a</mi><mi>r</mi><mi>d</mi><mo separator="true">⋅</mo><mi>N</mi><mi>e</mi><mi>a</mi><mi>r</mi><mo>+</mo><mi>t</mi><mi>o</mi><mi>T</mi><mi>o</mi><mi>p</mi><mo>−</mo><mi>t</mi><mi>o</mi><mi>R</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">TL=camera.forward·Near+toTop-toRight
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">d</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mi>R</mi><mo>=</mo><mi>c</mi><mi>a</mi><mi>m</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>f</mi><mi>o</mi><mi>r</mi><mi>w</mi><mi>a</mi><mi>r</mi><mi>d</mi><mo separator="true">⋅</mo><mi>N</mi><mi>e</mi><mi>a</mi><mi>r</mi><mo>+</mo><mi>t</mi><mi>o</mi><mi>T</mi><mi>o</mi><mi>p</mi><mo>+</mo><mi>t</mi><mi>o</mi><mi>R</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">TR=camera.forward·Near+toTop+toRight
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">d</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>B</mi><mi>L</mi><mo>=</mo><mi>c</mi><mi>a</mi><mi>m</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>f</mi><mi>o</mi><mi>r</mi><mi>w</mi><mi>a</mi><mi>r</mi><mi>d</mi><mo separator="true">⋅</mo><mi>N</mi><mi>e</mi><mi>a</mi><mi>r</mi><mo>−</mo><mi>t</mi><mi>o</mi><mi>T</mi><mi>o</mi><mi>p</mi><mo>−</mo><mi>t</mi><mi>o</mi><mi>R</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">BL = camera.forward·Near-toTop-toRight
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">d</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>B</mi><mi>R</mi><mo>=</mo><mi>c</mi><mi>a</mi><mi>m</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>f</mi><mi>o</mi><mi>r</mi><mi>w</mi><mi>a</mi><mi>r</mi><mi>d</mi><mo separator="true">⋅</mo><mi>N</mi><mi>e</mi><mi>a</mi><mi>r</mi><mo>−</mo><mi>t</mi><mi>o</mi><mi>T</mi><mi>o</mi><mi>p</mi><mo>+</mo><mi>t</mi><mi>o</mi><mi>R</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">BR = camera.forward·Near-toTop+toRight
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">d</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span></span></span></span></span></p>
<p>其中，<code>toTop</code>、<code>toRight</code>为：起点位于近平面中心，指向摄像机正上方和正右方，模长为近平面高度一半的向量。公式如下：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>h</mi><mi>a</mi><mi>l</mi><mi>f</mi><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>=</mo><mi>N</mi><mi>e</mi><mi>a</mi><mi>r</mi><mo>∗</mo><mi>t</mi><mi>a</mi><mi>n</mi><mo stretchy="false">(</mo><mfrac><mrow><mi>F</mi><mi>O</mi><mi>V</mi></mrow><mn>2</mn></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">halfHeight = Near * tan(\frac{FOV}{2})
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span></p>
<blockquote>
<p>此处，FOV为垂直FOV。<code>halfHeight</code>为近平面高度的一半。</p>
</blockquote>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>t</mi><mi>o</mi><mi>T</mi><mi>o</mi><mi>p</mi><mo>=</mo><mi>c</mi><mi>a</mi><mi>m</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>u</mi><mi>p</mi><mo>∗</mo><mi>h</mi><mi>a</mi><mi>l</mi><mi>f</mi><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">toTop = camera.up * halfHeight
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord">.</span><span class="mord mathnormal">u</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>t</mi><mi>o</mi><mi>R</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>=</mo><mi>c</mi><mi>a</mi><mi>m</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>∗</mo><mi>h</mi><mi>a</mi><mi>l</mi><mi>f</mi><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>s</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">toRight=camera.right * halfHeight.aspect
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span></span></span></span></span></p>
<p>完成向量计算后，根据图13.7中相似三角形，可以计算出任意点距离摄像机的距离dist：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo>=</mo><mfrac><mrow><mi mathvariant="normal">∣</mi><mtext>射线向量</mtext><mi mathvariant="normal">∣</mi></mrow><mrow><mi>N</mi><mi>e</mi><mi>a</mi><mi>r</mi></mrow></mfrac><mo>×</mo><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">dist=\frac{|射线向量|}{Near}×depth
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord cjk_fallback">射</span><span class="mord cjk_fallback">线</span><span class="mord cjk_fallback">向</span><span class="mord cjk_fallback">量</span><span class="mord">∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">p</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span></span></span></span></span></p>
<p>其中，射线向量模长由VS插值获得。</p>
<h4 id="计算"><a class="markdownIt-Anchor" href="#计算"></a> 计算</h4>
<p>首先，我们需要一个雾效系数f作为混合原始颜色和雾的颜色的Lerp因子。雾效系数有线性、指数和指数平方三种计算方式。分别如下：</p>
<ul>
<li>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;$&#039; in math mode at position 38: …_{max}-d_{min}}$̲$，其中d_max和d_min…'>f=\frac{d_{max}-|z|}{d_{max}-d_{min}}$$，其中d_max和d_min表示受雾影响的最大和最小距离
</p>
</li>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo>=</mo><msup><mi>e</mi><mrow><mo>−</mo><mo stretchy="false">(</mo><mi>d</mi><mo>−</mo><mi mathvariant="normal">∣</mi><mi>z</mi><mi mathvariant="normal">∣</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></msup></mrow><annotation encoding="application/x-tex">f=e^{-(d-|z|)^2}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0369199999999998em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0369199999999998em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">d</span><span class="mbin mtight">−</span><span class="mord mtight">∣</span><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="mord mtight">∣</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
</li>
</ul>
<p>本节中，我们使用线性雾，但并非基于距离，而是基于高度：$$f=\frac{h_{max}-|z|}{h_{max}-h_{min}}$$</p>
<p>MB脚本如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>()</span>&#123;<br>    camera.depthTextureMode |= DepthTextureMode.Depth;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span>(<span class="hljs-params">RenderTexture src, RenderTexture dest</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(material)&#123;<br>        Matrix4x4 frustumCorners = Matrix4x4 identity;<br>        <br>        <span class="hljs-built_in">float</span> fov = camera.fieldOfView;<br>        <span class="hljs-built_in">float</span> near = camera.nearClipPlane;<br>        <span class="hljs-built_in">float</span> far = camera.farClipPlane;<br>        <span class="hljs-built_in">float</span> aspect = camera.aspect;<br>        <br>        <span class="hljs-built_in">float</span> halfHeight = near * Mathf.Tan(fov*<span class="hljs-number">0.5f</span>*Mathf.Deg2Rad); <span class="hljs-comment">// 注意Tan接受的是弧度参数</span><br>        Vector3 toRight = cameraTransform.right * halfHeight * aspect;<br>        Vector3 toTop = cameraTransform.up * halfHeight;<br>        <br>        Vector3 topLeft = cameraTransform.forward * near + toTop - toRight;<br>        <span class="hljs-built_in">float</span> scale = topLeft.magnitude / near; <span class="hljs-comment">// 拿着这个去乘片段的深度就能知道它与相机的距离</span><br>        topLeft.Normalize();<br>        topLeft *= scale; <span class="hljs-comment">// 这样一来，向量的模长就是scale，而它本身的方向又说明了片段的偏移方向</span><br>        <br>        Vector3 topRight = cameraTransform.forward * near + top + toRight;<br>        topRight.Normalize();<br>        topRight *= scale;<br>        <br>        Vector3 bottomLeft = cameraTransform.forward * near - top - toRight;<br>        BottomLeft.Normalize();<br>        bottomLeft *= scale;<br>        <br>        Vector3 bottomRight = cameraTransform.forward * near - top + toRight;<br>        bottomRight.Normalize();<br>        bottomRight *= scale;<br>        <br>        frustumCorners.SetRow(<span class="hljs-number">0</span>, bottomLeft); <br>        frustumCorners.SetRow(<span class="hljs-number">1</span>, bottomRight); <br>        frustumCorners.SetRow(<span class="hljs-number">2</span>, topRight); <br>        frustumCorners.SetRow(<span class="hljs-number">3</span>, topLeft) ; <br>        material.SetMatrix(<span class="hljs-string">&quot;_FrustumCornersRay&quot;</span>, frustumCorners);<br>        material.SetMatrix(<span class="hljs-string">&quot;_ViewProjectionInverseMatrix&quot;</span>, (camera.projectionMatrix * camera.worldToCameraMatirx).inverse);<br>        material.SetFloat(<span class="hljs-string">&quot;_FogDensity&quot;</span>, fogDensity);<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>VS如下：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs glsl">struct v2f&#123;<br>    float4 pos : SV_POSITION;<br>    half2 uv : TEXCOORD0;<br>    half2 uv_depth : TEXCOORD1;<br>    float4 interpolatedRay : TEXCOORD2;<br>&#125;;<br>v2f vert(appdata_img v)&#123;   <br>    v2f o;<br>    o.pos = mul(UNITY_MATRIX_MVP, v.vertex);<br>    o.uv = v.texcoord;<br>    o.uv_depth = v.texcoord;<br>    <span class="hljs-comment">// D3D平台上为true</span><br>    <span class="hljs-meta">#if UNITY_UV_STARTS_AT_TOP</span><br>    <span class="hljs-keyword">if</span>(_MainTex_TexelSize.y &lt; <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 是否开启抗锯齿</span><br>        o.uv.depth.y = <br>    &#125;<br>    <span class="hljs-meta">#endif</span><br>    <span class="hljs-type">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">// 表示采用哪个Ray</span><br>    <span class="hljs-keyword">if</span>(v.texcoord.x &lt; <span class="hljs-number">0.5</span> &amp;&amp; v.texcoord.y &lt; <span class="hljs-number">0.5</span>) <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(v.texcoord.x &gt; <span class="hljs-number">0.5</span> &amp;&amp; v.texcoord.y &lt; <span class="hljs-number">0.5</span>) <span class="hljs-keyword">index</span> = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(v.texcoord.x &lt; <span class="hljs-number">0.5</span> &amp;&amp; v.texcoord.y &gt; <span class="hljs-number">0.5</span>) <span class="hljs-keyword">index</span> = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">index</span>=<span class="hljs-number">3</span>;<br>    <span class="hljs-meta">#if UNITY_UV_STARTS_AT_TOP</span><br>    <span class="hljs-keyword">if</span>(_MainTex_TexelSize.y &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">index</span> = <span class="hljs-number">3</span>-<span class="hljs-keyword">index</span>; <span class="hljs-comment">// 在D3D平台且开启了抗锯齿时，UV左上角为0,0</span><br>    <span class="hljs-meta">#endif</span><br>    o.interpolatedRay = _FrustumCornersRay[<span class="hljs-keyword">index</span>]; <span class="hljs-comment">// 行主序</span><br>    <span class="hljs-keyword">return</span> o;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>FS：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs glsl">fixed4 frag(v2f i) : SV_Target&#123;<br>    <span class="hljs-type">float</span> linearDepth = LinearEyeDepth(SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth)); <span class="hljs-comment">// 采样得到视角空间深度值（以相机为原点）</span><br>    float3 worldPos = _WorldSpaceCameraPos + linearDepth * i.interpolatedRay.xyz;<br>    <span class="hljs-type">float</span> fogDensity = (_FogEnd - worldPos.y) / (_FogEnd - _FogStart);<br>    fogDensity = saturate(fogDensity * _FogDensity);<br>    fixed4 finalColor = tex2D(_MainTex, i.uv);<br>    finalColor.rgb = lerp(finalColor.rgb, _FogColor.rgb, fogDensity);<br>    <span class="hljs-keyword">return</span> finalcolor;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>记得关闭Fallback。</p>
<h3 id="优化边缘检测"><a class="markdownIt-Anchor" href="#优化边缘检测"></a> 优化边缘检测</h3>
<p>本质上是把原先的卷积Color变为卷积DepthNormal，没有很大的区别，所以略。</p>
<h2 id="npr"><a class="markdownIt-Anchor" href="#npr"></a> NPR</h2>
<h3 id="卡渲"><a class="markdownIt-Anchor" href="#卡渲"></a> 卡渲</h3>
<h4 id="轮廓线"><a class="markdownIt-Anchor" href="#轮廓线"></a> 轮廓线</h4>
<p>有下列五种方案：</p>
<ol>
<li>基于菲涅尔的N dot V描边。简单快速，效果一般。</li>
<li>双Pass渲染。简单快速，效果较好，但不适合平整模型。</li>
<li>边缘检测。适用于任意模型，但深度、法线变化较小的轮廓无法检测。</li>
<li>轮廓边检测。即检查某条边相邻的三角形是否满足$$(n_0 · v &gt; 0)!=(n_1·v&gt;0)$$。存在动画连贯性问题。</li>
<li>混合方案。</li>
</ol>
<p>我们采用双Pass方案。在第一个Pass中，将模型顶点沿法线略微扩张，并且Cull Front。再渲染第二个Pass。核心代码如下：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">// 避免内凹模型背面面片遮挡正面的定式操作</span><br>viewNormal.z = <span class="hljs-number">-0.5</span>;<br>viewNormal = <span class="hljs-built_in">normalize</span>(viewNormal);<br>viewPos = viewPos + viewNormal * _Outline; <span class="hljs-comment">// 扩张顶点</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>我该如何理解第一个Pass的Cull Front？</p>
<p>实际上，我们看到的描边线是<strong>模型外壳的内部</strong>。</p>
</blockquote>
<h4 id="镜面反射"><a class="markdownIt-Anchor" href="#镜面反射"></a> 镜面反射</h4>
<p>前面提到，Blinn-Phong模型的镜面反射项如下：</p>
<p><code>float spec = pow(max(0.0,dot(normal, halfDir),_Gloss)</code></p>
<p>对于NPR的镜面反射，我们需要对spec进行step，以模拟小范围的纯色。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">float</span> spec = <span class="hljs-built_in">dot</span>(worldNormal, worldHalfDir);<br>spec = lerp(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-built_in">smoothstep</span>(-w, w, spec - threshold));.<br></code></pre></td></tr></table></figure>
<p>其中，<code>w</code>是一个很小的数值，可以理解为镜面反射区域与其他区域的过渡的宽度。之所以这么干是为了防止镜面反射的锯齿。</p>
<blockquote>
<p>w的数值既可以设置为极小的定值，也可以设置为<code>fwidth(spec)</code>。</p>
<p><code>fwidth(x)</code>用于计算当前像素与邻近像素的x变量的差值。也就是说，邻近像素的x值变化越大，函数返回值就越大。</p>
</blockquote>
<h4 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h4>
<p>VS:</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs glsl">struct v2f&#123;<br>    float4 pos : POSITION;<br>    float2 uv : TEXCOORD0;<br>    float3 worldNormal : TEXCOORD1;<br>    float3 worldPos : TEXCOORD2;<br>    SHADOW_COORDS(<span class="hljs-number">3</span>) <span class="hljs-comment">//注意这里没有分号，而且寄存器序号是3</span><br>&#125;<br>v2f vert (a2f v)&#123;<br>    v2f o;<br>    o.pos = mul(UNITY_MATRIX_MVP, v.vertex);<br>    o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br>    o.worldNormal = mul(v.normal, (float3x3)_World2Object);<br>    o.worldPos = mul(_Object2World, v.vertex).xyz;<br>    TRANSFER_SHADOW(o); <span class="hljs-comment">// 因为物体需要应用阴影，所以要加上</span><br>    <span class="hljs-keyword">return</span> o;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>FS:</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs glsl">float4 frag(v2f i) : SV_Target&#123;<br>    fixed3 worldNormal = <span class="hljs-built_in">normalize</span>(i.worldNormal);<br>    fixed3 worldLightDir = <span class="hljs-built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));<br>    fixed3 worldViewDir = <span class="hljs-built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));<br>    fixed3 worldHalfDir = <span class="hljs-built_in">normalize</span>(worldLightDir + worldViewDir);<br>    fixed4 c = tex2D(_MainTex, i.uv);<br>    fixed3 albedo = c.rgb * _Color.rgb;<br>    fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br>    UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos); <span class="hljs-comment">// 光照衰减</span><br>    fixed diff = <span class="hljs-built_in">dot</span>(worldNormal, worldLightDir);<br>    diff = (diff * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>) * atten; <span class="hljs-comment">//用于将漫反射从[-1,1]映射到[0,1]，让光照的整体范围更大，避免背光区一片漆黑</span><br>    fixed3 diffuse = _LightColor0.rgb * albedo * tex2D(_Ramp, float2(diff, diff)).rgb; <span class="hljs-comment">// 渐变纹理</span><br>    fixed spec = <span class="hljs-built_in">dot</span>(worldNormal, worldHalfDir);<br>    fixed w = <span class="hljs-built_in">fwidth</span>(spec) * <span class="hljs-number">2.0</span>; <span class="hljs-comment">//乘2是为了让边缘更柔和</span><br>    fixed3 specular = _Specular.rgb * lerp(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-built_in">smoothstep</span>(-w, w, spec + _SpecularScale - <span class="hljs-number">1</span>)) * <span class="hljs-built_in">step</span>(<span class="hljs-number">0.0001</span>, _SpecularScale); <span class="hljs-comment">// 用于在_SpecularScale == 0 时完全消除镜面反射，否则根据Blinn-phong模型，spec项始终不为0</span><br>    <span class="hljs-keyword">return</span> fixed4(ambient + diffuse + specular, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>记得<code>Fallback “Diffuse”</code></p>
<h3 id="基于tam的风格化渲染"><a class="markdownIt-Anchor" href="#基于tam的风格化渲染"></a> 基于TAM的风格化渲染</h3>
<p>色调艺术映射（Tonal Art Map, TAM）是一系列纹理，对应不同光照强度下所采用的类似于光照贴图的结构。如下：</p>
<p><img src="https://yoi-note.oss-cn-chengdu.aliyuncs.com/Image/202502081036540.png" srcset="/img/loading.gif" lazyload alt="image-20250208103656308" /></p>
<p>在本节，我们不考虑TAM中的Mipmap，而是单纯用六张纹理进行渲染。在VS渲染阶段，我们计算逐顶点光照，并根据结果决定六张纹理的混合权重，并传递给FS。</p>
<p>VS：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs glsl">struct v2f&#123;<br>    float4 pos : SV_POSITION;<br>    float2 uv : TEXCOORD0;<br>    fixed3 hatchWeights0 : TEXCOORD1; <br>    fixed3 hatchWeights1 : TEXCOORD2; <span class="hljs-comment">//六个通道，分别存储六张素描纹理的权重</span><br>    float3 worldPos : TEXCOORD3;<br>    SHADOW_COORDS(<span class="hljs-number">4</span>)<br>        &#125;;<br><br>    v2f vert(a2v v)&#123;<br>        v2f o;<br>        o.pos = mul(UNITY_MATRIX_MVP, v.vertex);<br>        o.uv = v.texcoord.xy * _TileFactor;<br>        fixed3 worldLightDir = <span class="hljs-built_in">normalize</span>(WorldSpaceLightDir(v.vertex));<br>        fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);<br>        fixed diff = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(worldLightDir, worldNormal));<br>        o.hatchWeights0 = fixed3(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        o.hatchWeights1 = fixed3(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-type">float</span> hatchFacotr = diff * <span class="hljs-number">7.0</span>; <span class="hljs-comment">// 漫反射强度必然在[0,1]之间</span><br>        <span class="hljs-keyword">if</span> (hatchFactor &gt; <span class="hljs-number">6.</span> <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 纯白</span><br>        <span class="hljs-comment">// 将[0-7]均匀划分为7个子区间，判断hashFactor所处区间来计算纹理混合权重</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hatch Factor &gt; <span class="hljs-number">5.</span> <span class="hljs-number">0</span>) &#123; <br>            o.hatchWeights0.x = hatchFactor - <span class="hljs-number">5.0</span>; <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hatchFactor &gt; <span class="hljs-number">4.0</span>) &#123; <br>            o.hatchWeights0.x = hatchFactor - <span class="hljs-number">4.0</span>; <br>            o.hatchWeights0.y = <span class="hljs-number">1.0</span> - o.hatchWeights0.x; <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hatchFactor &gt; <span class="hljs-number">3.</span> <span class="hljs-number">0</span>) &#123; <br>            o.hatchWeights0.y = hatchFactor - <span class="hljs-number">3.0</span>; <br>            o.hatchWeights0.z = <span class="hljs-number">1.0</span> - o.hatchWeights0.y; <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hatchFactor &gt; <span class="hljs-number">2.</span> <span class="hljs-number">0</span>) &#123; <br>            o.hatchWeights0.z = hatchFactor - <span class="hljs-number">2.0</span>; <br>            o.hatchWeights1.x = <span class="hljs-number">1</span> . <span class="hljs-number">0</span> - o.hatchWeights0.z; <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hatchFactor &gt; <span class="hljs-number">1.</span> <span class="hljs-number">0</span>) &#123; <br>            o.hatchWeights1.x = hatchFactor - <span class="hljs-number">1.0</span>; <br>            o.hatchWeights1.y = <span class="hljs-number">1.0</span> - o.hatchWeights1.x; <br>        &#125; <span class="hljs-keyword">else</span> &#123; <br>            o.hatchWeights1.y = hatchFactor; <br>            o.hatchWeights1.z = <span class="hljs-number">1.0</span> - o .hatchWeights1.y; <br>        &#125;<br>        o.worldPos = mul(_Object2World, v.vertex).xyz;<br>        TRANSFER_SHADOW(o);<br>        <span class="hljs-keyword">return</span> o;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>FS:</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs glsl">fixed4 frag(v2f i) : SV_Target&#123;<br>    fixed4 hatchTex0 = tex2D(_Hatch0, i.uv) * i.hatchWeights0.x; <br>    fixed4 hatchTex1 = tex2D(_Hatch1, i.uv) * i.hatchWeights0.y; <br>    fixed4 hatchTex2 = tex2D(_Hatch2, i.uv) * i.hatchWeights0.z; <br>    fixed4 hatchTex3 = tex2D(_Hatch3, i.uv) * i.hatchWeights1.x; <br>    fixed4 hatchTex4 = tex2D(_Hatch4, i.uv) * i.hatchWeights1.y; <br>    fixed4 hatchTex5 = tex2D(_Hatch5, i.uv) * i.hatchWeights1.z;<br>    fixed4 whiteColor = fixed4(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) * (<span class="hljs-number">1</span>-i.hatchWeight0.x - i.hatchWeights0.y - i.hatchWeights0.z - i.hatchWeights1.x - i.hatchWeights1.y - i.hatchWeights1.z); <span class="hljs-comment">// 计算纯白在渲染中的贡献度</span><br>    fixed4 hatchColor = hatchTex0 + hatchTex1 + hatchTex2 + hatchTex3 + hatchTex4 + hatchTex5 + whiteColor;<br>    UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);<br>    <span class="hljs-keyword">return</span> fixed4(hatchColor.rgb * _Color.rgb * atten, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>记得设置<code>Fallback “Diffuse”</code>。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Unity/" class="print-no-link">#Unity</a>
      
        <a href="/tags/Shader/" class="print-no-link">#Shader</a>
      
        <a href="/tags/%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF/" class="print-no-link">#技术美术</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Unity Shader学习笔记（四） - 后处理与NPR</div>
      <div>http://example.com/2025/02/10/Unity-Shader学习笔记（四）-后处理与NPR/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Yoi</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年2月10日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/02/10/Unity-Shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89-%E5%99%AA%E5%A3%B0%E3%80%81%E4%BC%98%E5%8C%96%E4%B8%8EPBS%E5%B7%A5%E4%BD%9C%E6%B5%81/" title="Unity Shader学习笔记（五） - 噪声、优化与PBS工作流">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Unity Shader学习笔记（五） - 噪声、优化与PBS工作流</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/02/02/Unity-Shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89-%E5%85%89%E7%85%A7%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E4%B8%8E%E6%97%B6%E9%97%B4%E5%8A%A8%E7%94%BB/" title="Unity Shader学习笔记（三） - 光照、高级纹理与时间动画">
                        <span class="hidden-mobile">Unity Shader学习笔记（三） - 光照、高级纹理与时间动画</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  




  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       Tech · Art · Life. |  <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
